---
phase: 08-validation-rules-and-orchestrator
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/x402lint/src/validation/orchestrator.ts
  - packages/x402lint/src/validation/index.ts
  - packages/x402lint/src/index.ts
autonomous: true

must_haves:
  truths:
    - "validate('not json') returns { valid: false, errors: [{code: 'INVALID_JSON'}], warnings: [], version: 'unknown', normalized: null }"
    - "validate(validV2Config) returns { valid: true, errors: [], version: 'v2', normalized: {...} }"
    - "validate(configWithSimpleName) returns a warning with fix suggestion containing the CAIP-2 equivalent"
    - "validate(config, { strict: true }) promotes all warnings to errors and returns valid: false if any warnings existed"
    - "validate() never throws -- all invalid inputs produce structured error results"
  artifacts:
    - path: "packages/x402lint/src/validation/orchestrator.ts"
      provides: "validate() function composing all rule modules into pipeline"
      exports: ["validate", "ValidationOptions"]
    - path: "packages/x402lint/src/validation/index.ts"
      provides: "Updated barrel export including orchestrator"
      exports: ["validate", "validateAddress", "validateEvmAddress", "validateSolanaAddress"]
    - path: "packages/x402lint/src/index.ts"
      provides: "Updated SDK entry point exporting validate()"
      exports: ["validate"]
  key_links:
    - from: "packages/x402lint/src/validation/orchestrator.ts"
      to: "packages/x402lint/src/validation/rules/index.ts"
      via: "imports all rule validators"
      pattern: "import.*from.*rules"
    - from: "packages/x402lint/src/validation/orchestrator.ts"
      to: "packages/x402lint/src/detection/normalize.ts"
      via: "calls normalize() on parsed input"
      pattern: "import.*normalize"
    - from: "packages/x402lint/src/validation/orchestrator.ts"
      to: "packages/x402lint/src/validation/address.ts"
      via: "calls validateAddress() for each accepts entry"
      pattern: "import.*validateAddress"
    - from: "packages/x402lint/src/index.ts"
      to: "packages/x402lint/src/validation/orchestrator.ts"
      via: "re-exports validate"
      pattern: "export.*validate"
---

<objective>
Build the validate() orchestrator that composes all rule modules into a single pipeline, and wire it into the public SDK API.

Purpose: This is the core public API -- the function developers call. It takes any input (string or object), runs it through the full validation pipeline (parse -> detect -> normalize -> validate rules -> collect issues -> strict mode), and returns a structured ValidationResult. This is the plan that makes the SDK usable.

Output: orchestrator.ts with validate(), updated barrel exports, updated SDK entry point.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-validation-rules-and-orchestrator/08-RESEARCH.md
@.planning/phases/08-validation-rules-and-orchestrator/08-01-SUMMARY.md

@packages/x402lint/src/types/validation.ts
@packages/x402lint/src/types/errors.ts
@packages/x402lint/src/types/config.ts
@packages/x402lint/src/detection/normalize.ts
@packages/x402lint/src/validation/address.ts
@packages/x402lint/src/validation/rules/index.ts
@packages/x402lint/src/validation/index.ts
@packages/x402lint/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create orchestrator with validate() pipeline</name>
  <files>
    packages/x402lint/src/validation/orchestrator.ts
  </files>
  <action>
Create `packages/x402lint/src/validation/orchestrator.ts` implementing the validate() function.

**Exports:**
- `interface ValidationOptions { strict?: boolean | undefined }`
- `function validate(input: string | object, options?: ValidationOptions): ValidationResult`

**Pipeline implementation** (follow the research pattern closely):

```
1. STRUCTURE (Level 1)
   Call validateStructure(input).
   If issues non-empty, return early with { valid: false, version: format || 'unknown', errors: issues, warnings: [], normalized: null }.
   Extract parsed object and format from result.

2. NORMALIZE
   Call normalize(parsed) from detection module.
   If normalize returns null (should be rare since structure passed), return { valid: false, version: format, errors: [UNKNOWN_FORMAT issue], warnings: [], normalized: null }.
   Store normalized result.

3. COLLECT ISSUES
   Initialize errors: ValidationIssue[] = [] and warnings: ValidationIssue[] = [].

4. VERSION (Level 2)
   Push validateVersion(normalized, format) results into errors.

5. ACCEPTS (Level 2)
   Call validateAccepts(normalized). Push results into errors.

6. RESOURCE (Level 2)
   Call validateResource(normalized, format). Push results into warnings (resource absence is a warning).

7. FIELDS + NETWORK + AMOUNT + ADDRESS + TIMEOUT (Level 3-4)
   Only if normalized.accepts is a non-empty array.
   For each entry at index i:
     const fieldPath = `accepts[${i}]`
     - Push validateFields(entry, fieldPath) results into errors
     - Push validateNetwork(entry, fieldPath) results: check each issue's severity, push errors to errors, warnings to warnings
     - Push validateAsset(entry, fieldPath) results into warnings
     - Push validateAmount(entry, fieldPath) results into errors
     - Push validateTimeout(entry, fieldPath, format) results into warnings
     - If entry.payTo and entry.network both exist (non-empty):
       Call validateAddress(entry.payTo, entry.network, `${fieldPath}.payTo`).
       Sort by severity: errors go to errors array, warnings go to warnings array.

8. LEGACY (Level 5)
   Push validateLegacy(normalized, format, parsed as object) results into warnings.

9. STRICT MODE
   If options?.strict === true:
     For each warning, create a new issue with { ...warning, severity: 'error' } and push to errors.
     Set warnings to empty array (warnings.length = 0).

10. RETURN
    Return {
      valid: errors.length === 0,
      version: format,
      errors,
      warnings,
      normalized,
    }
```

**Critical details:**
- validate() NEVER throws. Wrap entire function body in try/catch as safety net. If unexpected error occurs, return `{ valid: false, version: 'unknown', errors: [{ code: ErrorCode.UNKNOWN_FORMAT, field: '$', message: 'Unexpected validation error', severity: 'error' }], warnings: [], normalized: null }`.
- Import ValidationResult from `../../types/validation` (NOT from barrel to avoid potential circular issues -- actually, importing from `../types` barrel is fine since types don't import from validation).
- Import normalize from `../detection/normalize` (NOT from barrel).
- Import validateAddress from `./address`.
- Import all rule validators from `./rules`.
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/x402lint && npx tsc --noEmit -p packages/x402lint/tsconfig.json` -- no type errors.
  </verify>
  <done>
orchestrator.ts exports validate() and ValidationOptions. The function composes all rule modules into a pipeline that accumulates errors/warnings and supports strict mode. It never throws.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire validate() into barrel exports and SDK entry point</name>
  <files>
    packages/x402lint/src/validation/index.ts
    packages/x402lint/src/index.ts
  </files>
  <action>
**Update `packages/x402lint/src/validation/index.ts`:**
Add exports for the orchestrator. The file currently exports address validators only. Add:
```typescript
export { validate } from './orchestrator'
export type { ValidationOptions } from './orchestrator'
```
Keep existing exports (`validateEvmAddress`, `validateSolanaAddress`, `validateAddress`).

**Update `packages/x402lint/src/index.ts`:**
Replace the commented-out Phase 8 placeholder with the real export. Change:
```typescript
// Re-export validation orchestrator when available (Phase 8)
// export { validate } from './validation'
```
To:
```typescript
// Re-export validation orchestrator (Phase 8)
export { validate } from './validation'
export type { ValidationOptions } from './validation'
```
Keep all existing exports intact.
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/x402lint && npx tsc --noEmit -p packages/x402lint/tsconfig.json` -- no type errors. Verify `validate` is exported by checking: `grep -n 'export.*validate' packages/x402lint/src/index.ts`.
  </verify>
  <done>
validate() is exported from SDK entry point. `import { validate } from 'x402lint'` will work once built. ValidationOptions type is also exported for TypeScript consumers.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/rawgroundbeef/Projects/x402lint && npx tsc --noEmit -p packages/x402lint/tsconfig.json` passes with zero errors
2. `grep 'export.*validate' packages/x402lint/src/index.ts` shows validate export
3. No circular imports (types <- validation -> detection -> types would be circular, but types only export interfaces/types, not runtime code)
</verification>

<success_criteria>
- validate('not json') returns valid:false with INVALID_JSON error
- validate(validV2) returns valid:true with normalized output
- validate(config, { strict: true }) promotes warnings to errors
- validate() never throws on any input
- validate is exported from SDK entry point
</success_criteria>

<output>
After completion, create `.planning/phases/08-validation-rules-and-orchestrator/08-02-SUMMARY.md`
</output>
