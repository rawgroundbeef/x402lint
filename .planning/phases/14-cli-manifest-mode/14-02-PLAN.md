---
phase: 14-cli-manifest-mode
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - packages/x402lint/src/cli/format.ts
  - packages/x402lint/src/cli.ts
  - packages/x402lint/tsdown.config.ts
autonomous: true

must_haves:
  truths:
    - "x402lint manifest.json auto-detects manifest and shows per-endpoint summary table + details"
    - "x402lint config.json auto-detects single config and shows existing output (no regression)"
    - "--json outputs pure JSON parseable by JSON.parse() with no ANSI codes"
    - "--quiet suppresses all output, communicates via exit code only"
    - "--strict --json outputs strict-mode JSON"
    - "--quiet takes precedence over --json"
    - "Detection announcement printed before results (e.g. Detected: manifest with N endpoints)"
    - "Wild manifest normalization warnings shown before validation results"
    - "Exit 0 if majority endpoints pass, exit 1 if majority fail"
    - "Exit 2 for input errors (file not found, network error, invalid JSON)"
    - "--header flag passes custom headers to URL fetch"
    - "Dash (-) as positional reads from stdin"
  artifacts:
    - path: "packages/x402lint/src/cli/format.ts"
      provides: "Terminal output formatting for manifest and single-config results"
      exports: ["formatManifestResult", "formatValidationResult", "formatCheckResult"]
      min_lines: 80
    - path: "packages/x402lint/src/cli.ts"
      provides: "Main CLI entry point with manifest routing"
      min_lines: 80
  key_links:
    - from: "packages/x402lint/src/cli.ts"
      to: "packages/x402lint/src/cli/detect.ts"
      via: "resolveInput() for manifest vs config routing"
      pattern: "resolveInput"
    - from: "packages/x402lint/src/cli.ts"
      to: "packages/x402lint/src/validation/manifest.ts"
      via: "validateManifest() import for manifest path"
      pattern: "validateManifest"
    - from: "packages/x402lint/src/cli/format.ts"
      to: "cli-table3"
      via: "Table import for summary table rendering"
      pattern: "import.*Table.*from.*cli-table3"
    - from: "packages/x402lint/src/cli.ts"
      to: "packages/x402lint/src/cli/args.ts"
      via: "parseCliArgs for argument parsing"
      pattern: "parseCliArgs"
---

<objective>
Create manifest output formatting and rewrite the CLI entry point to route manifests to validateManifest() with summary table + endpoint details, while preserving existing single-config output exactly as-is.

Purpose: This is the core CLI manifest mode — everything connects here to deliver the MAN-06 requirement.
Output: Working CLI that auto-detects manifest vs single-config and displays appropriate output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-cli-manifest-mode/14-CONTEXT.md
@.planning/phases/14-cli-manifest-mode/14-RESEARCH.md
@.planning/phases/14-cli-manifest-mode/14-01-SUMMARY.md
@packages/x402lint/src/cli.ts
@packages/x402lint/src/cli/args.ts
@packages/x402lint/src/cli/fetch.ts
@packages/x402lint/src/cli/detect.ts
@packages/x402lint/src/index.ts
@packages/x402lint/src/types/manifest.ts
@packages/x402lint/src/types/validation.ts
@packages/x402lint/src/validation/manifest.ts
@packages/x402lint/src/validation/orchestrator.ts
@packages/x402lint/src/check.ts
@packages/x402lint/tsdown.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create format module with manifest table output</name>
  <files>packages/x402lint/src/cli/format.ts</files>
  <action>
    Create `src/cli/format.ts` with terminal output formatting for both manifest and single-config results.

    **Color helpers:**
    - Detect color support: `const useColor = process.stdout.isTTY && !process.env.NO_COLOR`
    - Helper functions: `green(s)`, `red(s)`, `yellow(s)`, `cyan(s)`, `dim(s)` that wrap with ANSI codes only when `useColor` is true
    - CRITICAL: In `--json` mode, formatters return `JSON.stringify()` directly. In `--quiet` mode, return empty string. Color is ONLY used in terminal (non-json, non-quiet) mode.

    **Export function `formatIssue(issue: ValidationIssue, colorEnabled: boolean): string`:**
    - Same logic as existing cli.ts formatIssue but respects colorEnabled param
    - Icon: red cross for error, yellow warning for warning
    - Format: `  {icon} {code} [{field}]: {message}`
    - If fix exists: append `\n      -> {fix}`

    **Export function `formatValidationResult(result: ValidationResult, args: CliArgs): string`:**
    - Port existing logic from cli.ts `formatValidationResult()` exactly as-is
    - json mode: `JSON.stringify(result, null, 2)`
    - quiet mode: `''`
    - Terminal mode: Valid/Invalid status, errors, warnings (identical to current output)

    **Export function `formatCheckResult(result: CheckResult, args: CliArgs): string`:**
    - Port existing logic from cli.ts `formatCheckResult()` exactly as-is
    - json mode: `JSON.stringify(result, null, 2)`
    - quiet mode: `''`
    - Terminal: extraction status, payment options summary, errors, warnings

    **Export function `formatManifestResult(result: ManifestValidationResult, args: CliArgs): string`:**
    - json mode: `JSON.stringify(result, null, 2)` — pure JSON, no ANSI
    - quiet mode: `''`
    - Terminal mode:
      1. **Summary table** using cli-table3:
         - Import Table from 'cli-table3'
         - Columns: Status (icon), Endpoint, Errors, Warnings
         - For each entry in `result.endpointResults`: row with pass/fail icon, endpoint ID, error count, warning count
         - Use compact style (no outer borders, horizontal lines between rows)
      2. **Endpoint details** for ALL endpoints (both passing and failing):
         - Section header: `--- {endpointId} ---`
         - Status line: `{icon} {Valid|Invalid} (v2)` using the endpoint's ValidationResult
         - List errors and warnings using formatIssue()
         - Blank line between endpoints
      3. **Cross-endpoint issues** at the end (after all endpoint details):
         - Only show section if `result.errors.length > 0 || result.warnings.length > 0`
         - Header: `Cross-endpoint issues:`
         - List errors then warnings using formatIssue()

    **Export function `calculateExitCode(result: ManifestValidationResult, strict: boolean): number`:**
    - Empty endpoints (0 entries): return 0 (valid, per Phase 11 decision)
    - Count passing vs failing endpoints:
      - In strict mode: endpoint passes only if `valid && warnings.length === 0`
      - In normal mode: endpoint passes if `valid`
    - If `result.errors.length > 0` (manifest-level errors): return 1
    - If strict and `result.warnings.length > 0` (manifest-level warnings): return 1
    - Return 0 if passingCount > failingCount, else 1
    - Tie (equal pass/fail): return 1 (fail-safe)

    Import types from the SDK: ValidationIssue, ValidationResult, ManifestValidationResult, CheckResult.
    Import CliArgs from './args'.
  </action>
  <verify>
    Run `pnpm --filter x402lint exec tsc --noEmit` to verify types compile.
    Verify the file exports all four formatting functions plus calculateExitCode.
  </verify>
  <done>
    format.ts exports formatManifestResult with cli-table3 summary table, formatValidationResult (ported), formatCheckResult (ported), calculateExitCode with majority logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite cli.ts with manifest routing and update build config</name>
  <files>
    packages/x402lint/src/cli.ts
    packages/x402lint/tsdown.config.ts
  </files>
  <action>
    **Rewrite `src/cli.ts`** to compose the CLI modules from Plan 01 and Task 1.

    The new cli.ts should:

    1. **Import modules:**
       - `parseCliArgs` from `./cli/args`
       - `fetchWithRedirects` from `./cli/fetch`
       - `resolveInput, readStdin, isUrl` from `./cli/detect`
       - `formatManifestResult, formatValidationResult, formatCheckResult, calculateExitCode` from `./cli/format`
       - `validate` from `./validation/orchestrator`
       - `validateManifest` from `./validation/manifest`
       - `check` from `./check`
       - `VERSION` from `./index`
       - `detect` from `./detection/detect`
       - `isManifestConfig` from `./detection/guards`
       - `normalizeWildManifest` from `./detection/wild-manifest`
       - Types: ManifestConfig, ManifestValidationResult

    2. **Help text:**
       Update the HELP constant to include:
       - `x402lint <manifest.json>` example
       - `x402lint -` stdin example
       - `--header` flag documentation (repeatable, for URL fetching)
       - Clarify exit codes: 0=valid/majority pass, 1=invalid/majority fail, 2=input error
       - Keep existing examples and add manifest examples

    3. **Main function flow:**
       ```
       async function main(): Promise<number> {
         const args = parseCliArgs(process.argv.slice(2))

         if (args.version) { console.log(VERSION); return 0 }
         if (args.help) { console.log(HELP); return 0 }

         // Resolve input source
         let rawInput: string | null = args.input

         // Handle dash (-) stdin convention
         if (rawInput === '-') {
           rawInput = await readStdin()
           if (!rawInput.trim()) {
             console.error('No input from stdin.')
             return 2
           }
         }

         // Try stdin if no positional arg
         if (!rawInput) {
           const stdinData = await readStdin()
           if (stdinData.trim()) rawInput = stdinData.trim()
         }

         if (!rawInput) {
           console.error('No input provided. Run x402lint --help for usage.')
           return 2
         }

         // URL mode: fetch then detect manifest vs single
         if (isUrl(rawInput)) {
           return handleUrl(rawInput, args)
         }

         // File or inline JSON mode
         return handleFileOrJson(rawInput, args)
       }
       ```

    4. **handleUrl(url, args):**
       - Wrap in try/catch, catch returns exit 2 with error message
       - `fetchWithRedirects(url, { headers: args.headers })` to get response
       - If body is an object, detect format:
         - If manifest: print detection announcement, validateManifest(), format, exit code
         - If single config: use `check()` for URL responses (extracts from headers + body), format, exit code
       - If body is string, try JSON.parse:
         - If parseable and manifest: validateManifest flow
         - Otherwise: check() flow
       - Detection announcement (non-quiet, non-json): `console.log('Detected: manifest with N endpoints')` or `console.log('Detected: v2 config')`
       - Non-402 status: still print `HTTP {status} (expected 402)` for single configs, but for manifests just proceed (manifests come from well-known URLs, not 402 responses)

    5. **handleFileOrJson(rawInput, args):**
       - Wrap in try/catch, catch returns exit 2 with error message
       - Use `resolveInput(rawInput)` from detect module
       - If result.type is 'manifest':
         - Print normalization warnings if present (non-quiet, non-json): `console.log('Normalized: {warning}')` for each
         - Print detection announcement: `Detected: manifest with N endpoints`
         - `validateManifest(result.data as ManifestConfig)` with strict option
         - For strict mode: need to handle post-validation — if args.strict, promote all warnings to errors in each endpoint result AND in manifest-level warnings. Do this by: running validateManifest first, then if strict, iterate endpointResults and promote warnings to errors, and promote manifest warnings to errors.
           Actually, validateManifest internally calls validate() which does NOT apply strict mode (it takes the ManifestConfig object, not options). So strict mode must be applied POST-validation in the CLI:
           - For each endpoint in endpointResults: move warnings to errors with severity: 'error'
           - For manifest-level: move warnings to errors with severity: 'error'
           - Recompute valid: all endpointResults valid && no manifest errors
         - Format with `formatManifestResult(result, args)`
         - Exit code from `calculateExitCode(result, args.strict)`
       - If result.type is 'single-config':
         - Print detection announcement: `Detected: {format} config` where format comes from the result version
         - `validate(result.data, { strict: args.strict })`
         - Format with `formatValidationResult(result, args)`
         - Exit 0 if valid, 1 if invalid

    6. **Exit and error handling:**
       - `main().then(code => process.exit(code), err => { console.error(...); process.exit(2) })`

    **Detection announcements** (per CONTEXT.md):
    - Only show in terminal mode (not --json, not --quiet)
    - Manifest: `Detected: manifest with {N} endpoints`
    - Single config: `Detected: {version} config` (e.g., "Detected: v2 config")

    **Strict mode for manifests:**
    Since `validateManifest()` doesn't accept options, apply strict mode in CLI after getting results:
    - Create a helper `applyStrictMode(result: ManifestValidationResult): ManifestValidationResult` that:
      - For each endpoint result: promotes warnings to errors
      - Promotes manifest-level warnings to errors
      - Recomputes valid flag
    - Call this before formatting if args.strict is true

    **tsdown.config.ts update:**
    The CLI binary entry in tsdown.config.ts currently has `external: []`. cli-table3 needs to be bundled into the CLI (not external). Since it's already `external: []`, tsdown will bundle cli-table3 into cli.mjs. No change needed UNLESS cli-table3 causes issues.

    Actually, check: tsdown may need `cli-table3` to be resolvable at build time. Since it's a devDependency and tsdown bundles everything, this should work. But the CLI entry should NOT be `platform: 'browser'` — it's already `platform: 'node'`, which is correct.

    One concern: cli-table3 has a dependency (string-width). tsdown should bundle both transitively. Verify by running `pnpm --filter x402lint build` after changes.

    If cli-table3 causes bundling issues with tsdown (e.g., CJS-only modules), fall back to a simple hand-rolled table using string padding. The research noted this as a possibility.
  </action>
  <verify>
    1. `pnpm --filter x402lint build` succeeds (CLI binary builds)
    2. `node packages/x402lint/dist/cli.mjs --help` shows updated help with manifest examples and --header flag
    3. `node packages/x402lint/dist/cli.mjs --version` prints version
    4. Create a test manifest file and run: `node packages/x402lint/dist/cli.mjs /path/to/manifest.json` — should show summary table + endpoint details
    5. `node packages/x402lint/dist/cli.mjs --json /path/to/manifest.json` outputs parseable JSON
    6. `node packages/x402lint/dist/cli.mjs /path/to/valid-v2-base.json` still works (no regression on single configs)
    7. Verify exit codes: valid manifest -> 0, invalid config -> 1, nonexistent file -> 2
  </verify>
  <done>
    CLI auto-detects manifest vs single-config, displays summary table for manifests, preserves existing single-config output, all flags compose correctly, exit codes are meaningful.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter x402lint build` succeeds with no errors
2. `pnpm --filter x402lint exec tsc --noEmit` passes
3. Manual test: manifest.json input shows summary table + endpoint details
4. Manual test: config.json input shows existing output unchanged
5. Manual test: `--json` with manifest outputs parseable JSON
6. Manual test: `--quiet` with manifest produces no output, correct exit code
7. Manual test: `--strict` with manifest promotes warnings to errors
</verification>

<success_criteria>
- Manifest input auto-detected and validated with per-endpoint summary table
- Single-config input works identically to before (no regression)
- --json, --quiet, --strict, --header flags all work and compose correctly
- Exit codes: 0 (majority pass), 1 (majority fail), 2 (input errors)
- Detection announcement shown before results
- Build succeeds, CLI binary works
</success_criteria>

<output>
After completion, create `.planning/phases/14-cli-manifest-mode/14-02-SUMMARY.md`
</output>
