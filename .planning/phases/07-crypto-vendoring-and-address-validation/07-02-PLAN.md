---
phase: 07-crypto-vendoring-and-address-validation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - packages/x402check/src/validation/evm-address.ts
  - packages/x402check/src/validation/solana-address.ts
  - packages/x402check/src/validation/address.ts
  - packages/x402check/src/validation/index.ts
  - packages/x402check/src/index.ts
  - packages/x402check/test/validation/evm-address.test.ts
  - packages/x402check/test/validation/solana-address.test.ts
  - packages/x402check/test/validation/address.test.ts
autonomous: true

must_haves:
  truths:
    - "EIP-55 checksummed address '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed' passes with zero issues"
    - "All-lowercase EVM address produces NO_EVM_CHECKSUM warning (not error)"
    - "Incorrectly checksummed EVM address produces BAD_EVM_CHECKSUM warning (not error)"
    - "Invalid EVM format (wrong length, no 0x, bad hex) produces INVALID_EVM_ADDRESS error"
    - "Valid Solana address (32-44 Base58 chars, decodes to 32 bytes) passes with zero issues"
    - "Invalid Solana address produces INVALID_SOLANA_ADDRESS error"
    - "EVM address on Solana network produces INVALID_SOLANA_ADDRESS error (dispatch catches it)"
    - "Solana address on EVM network produces INVALID_EVM_ADDRESS error (dispatch catches it)"
    - "validateAddress dispatches by CAIP-2 namespace (eip155 -> EVM, solana -> Solana)"
    - "Unknown CAIP-2 namespace produces warning, not error"
    - "Stellar and Aptos namespaces accept any address (no deep validation yet)"
  artifacts:
    - path: "packages/x402check/src/validation/evm-address.ts"
      provides: "validateEvmAddress(address, field) -> ValidationIssue[]"
      exports: ["validateEvmAddress"]
    - path: "packages/x402check/src/validation/solana-address.ts"
      provides: "validateSolanaAddress(address, field) -> ValidationIssue[]"
      exports: ["validateSolanaAddress"]
    - path: "packages/x402check/src/validation/address.ts"
      provides: "validateAddress(address, network, field) -> ValidationIssue[] with CAIP-2 dispatch"
      exports: ["validateAddress"]
    - path: "packages/x402check/src/validation/index.ts"
      provides: "Barrel re-exports for all validation modules"
    - path: "packages/x402check/src/index.ts"
      provides: "Re-exports crypto and validation modules"
      contains: "export.*crypto"
  key_links:
    - from: "packages/x402check/src/validation/evm-address.ts"
      to: "packages/x402check/src/crypto/eip55.ts"
      via: "import { toChecksumAddress, isValidChecksum }"
      pattern: "import.*from.*crypto"
    - from: "packages/x402check/src/validation/solana-address.ts"
      to: "packages/x402check/src/crypto/base58.ts"
      via: "import { decodeBase58 }"
      pattern: "import.*decodeBase58.*from.*crypto"
    - from: "packages/x402check/src/validation/address.ts"
      to: "packages/x402check/src/registries/networks.ts"
      via: "import { getNetworkNamespace }"
      pattern: "import.*getNetworkNamespace.*from.*registries"
    - from: "packages/x402check/src/validation/address.ts"
      to: "packages/x402check/src/validation/evm-address.ts"
      via: "import { validateEvmAddress }"
      pattern: "import.*validateEvmAddress"
    - from: "packages/x402check/src/validation/address.ts"
      to: "packages/x402check/src/validation/solana-address.ts"
      via: "import { validateSolanaAddress }"
      pattern: "import.*validateSolanaAddress"
---

<objective>
Create chain-specific address validation modules that dispatch by CAIP-2 namespace, with EVM checksum verification and Solana byte-length validation, plus comprehensive test suites including cross-chain mismatch detection.

Purpose: Address validation is the deepest layer of x402 config validation. It catches address format errors, checksum issues (EVM), byte-length violations (Solana), and cross-chain mismatches (EVM address on Solana network). Phase 8's orchestrator will call validateAddress() for each accepts entry's payTo field.

Output: Three validation modules (evm-address, solana-address, address dispatch), barrel export, updated src/index.ts, and test suites covering valid/invalid addresses, checksum warnings, and cross-chain mismatches.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-crypto-vendoring-and-address-validation/07-RESEARCH.md
@.planning/phases/07-crypto-vendoring-and-address-validation/07-01-SUMMARY.md

@packages/x402check/src/types/errors.ts
@packages/x402check/src/types/validation.ts
@packages/x402check/src/registries/networks.ts
@packages/x402check/src/crypto/index.ts
@packages/x402check/src/crypto/keccak256.ts
@packages/x402check/src/crypto/base58.ts
@packages/x402check/src/crypto/eip55.ts
@packages/x402check/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: EVM and Solana address validation modules with dispatch</name>
  <files>
    packages/x402check/src/validation/evm-address.ts
    packages/x402check/src/validation/solana-address.ts
    packages/x402check/src/validation/address.ts
    packages/x402check/src/validation/index.ts
    packages/x402check/src/index.ts
  </files>
  <action>
    1. Remove `packages/x402check/src/validation/.gitkeep` (directory will have real files).

    2. Create `packages/x402check/src/validation/evm-address.ts`:
       - Import `{ toChecksumAddress, isValidChecksum }` from `../crypto/eip55`
       - Import `{ ErrorCode }` from `../types/errors`
       - Import type `{ ValidationIssue }` from `../types/validation`
       - Define `const EVM_ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/`
       - Export function `validateEvmAddress(address: string, field: string): ValidationIssue[]`:
         a. If address does not match EVM_ADDRESS_REGEX, return one error:
            `{ code: ErrorCode.INVALID_EVM_ADDRESS, field, message: 'EVM address must be 42 hex characters with 0x prefix', severity: 'error', fix: 'Format: 0x followed by 40 hex digits (0-9, a-f, A-F)' }`
            Return immediately (no further checks).
         b. Check if address is all-lowercase (`address === address.toLowerCase()`):
            If yes, return one warning:
            `{ code: ErrorCode.NO_EVM_CHECKSUM, field, message: 'EVM address is all-lowercase with no checksum protection', severity: 'warning', fix: 'Use checksummed address to detect typos: ' + toChecksumAddress(address) }`
            Note: Include the computed checksum address in the fix suggestion. Return — do NOT also check isValidChecksum (all-lowercase will always fail checksum comparison).
         c. Check if address is all-uppercase (address.slice(2) matches /^[0-9A-F]{40}$/):
            If yes, return empty array — all-uppercase is valid and does not carry checksum info. No warning needed (it's a common format).
         d. Otherwise address is mixed-case, check isValidChecksum(address):
            If false, return one warning:
            `{ code: ErrorCode.BAD_EVM_CHECKSUM, field, message: 'EVM address has invalid checksum (EIP-55)', severity: 'warning', fix: 'Expected: ' + toChecksumAddress(address) }`
            Note: Include the correct checksum in the fix.
         e. Return empty array if all checks pass.

    3. Create `packages/x402check/src/validation/solana-address.ts`:
       - Import `{ decodeBase58 }` from `../crypto/base58`
       - Import `{ ErrorCode }` from `../types/errors`
       - Import type `{ ValidationIssue }` from `../types/validation`
       - Define `const SOLANA_ADDRESS_REGEX = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/` (Base58 alphabet, 32-44 chars)
       - Export function `validateSolanaAddress(address: string, field: string): ValidationIssue[]`:
         a. If address does not match SOLANA_ADDRESS_REGEX, return one error:
            `{ code: ErrorCode.INVALID_SOLANA_ADDRESS, field, message: 'Solana address must be 32-44 Base58 characters', severity: 'error', fix: 'Valid characters: 1-9, A-H, J-N, P-Z, a-k, m-z (no 0, O, I, l)' }`
            Return immediately (don't attempt decode on invalid chars — DoS protection).
         b. Try decodeBase58(address):
            If decoded.length !== 32, return one error:
            `{ code: ErrorCode.INVALID_SOLANA_ADDRESS, field, message: 'Solana address must decode to 32 bytes, got ' + decoded.length, severity: 'error', fix: 'Verify address is a valid Solana public key' }`
         c. On catch: return one error:
            `{ code: ErrorCode.INVALID_SOLANA_ADDRESS, field, message: 'Invalid Base58 encoding', severity: 'error', fix: error instanceof Error ? error.message : 'Check Base58 encoding' }`
         d. Return empty array if valid.

    4. Create `packages/x402check/src/validation/address.ts`:
       - Import `{ getNetworkNamespace }` from `../registries/networks`
       - Import `{ validateEvmAddress }` from `./evm-address`
       - Import `{ validateSolanaAddress }` from `./solana-address`
       - Import `{ ErrorCode }` from `../types/errors`
       - Import type `{ ValidationIssue }` from `../types/validation`
       - Export function `validateAddress(address: string, network: string, field: string): ValidationIssue[]`:
         a. Extract namespace: `const namespace = getNetworkNamespace(network)`
         b. If namespace is undefined (invalid CAIP-2), return empty array — network format errors are caught elsewhere (by network validation rules in Phase 8). Address validation should not duplicate that concern.
         c. Dispatch by namespace:
            - `'eip155'`: return `validateEvmAddress(address, field)`
            - `'solana'`: return `validateSolanaAddress(address, field)`
            - `'stellar'`: return `[]` (accept any string — deep validation deferred)
            - `'aptos'`: return `[]` (accept any string — deep validation deferred)
            - default (unknown namespace): return `[]` (unknown namespaces are already warned about by registry validation in Phase 8)
         d. Note: Cross-chain mismatch detection happens naturally. If an EVM-format address (0x...) is passed with a solana:* network, dispatch sends it to validateSolanaAddress which rejects it (fails Base58 regex). If a Solana-format address is passed with eip155:* network, dispatch sends it to validateEvmAddress which rejects it (fails 0x prefix check). No explicit cross-chain detection code needed — dispatch handles it.

    5. Create `packages/x402check/src/validation/index.ts`:
       ```typescript
       // Validation barrel export
       export { validateEvmAddress } from './evm-address'
       export { validateSolanaAddress } from './solana-address'
       export { validateAddress } from './address'
       ```

    6. Update `packages/x402check/src/index.ts`:
       - Add export for crypto: `export * from './crypto'`
       - Add export for validation: `export { validateAddress, validateEvmAddress, validateSolanaAddress } from './validation'`
       - Keep existing exports (types, registries, detection, VERSION)
       - Note: Do NOT uncomment the `validate` line yet — that is Phase 8

    IMPORTANT: Use ErrorCode constants (ErrorCode.INVALID_EVM_ADDRESS) not string literals ('INVALID_EVM_ADDRESS').
    IMPORTANT: The fix field in NO_EVM_CHECKSUM and BAD_EVM_CHECKSUM should include the computed correct checksum address to make the fix actionable.
    IMPORTANT: Do NOT add an explicit ADDRESS_NETWORK_MISMATCH error code — cross-chain mismatches are caught by the dispatch pattern (wrong format for the chain = format error). The ADDRESS_NETWORK_MISMATCH code already exists in errors.ts but is reserved for Phase 8 orchestrator use if needed.
  </action>
  <verify>
    Run `cd packages/x402check && pnpm exec tsc --noEmit` — no TypeScript errors.
    Verify barrel exports: `import { validateAddress, validateEvmAddress, validateSolanaAddress } from './src/validation'` resolves.
  </verify>
  <done>
    validateEvmAddress, validateSolanaAddress, and validateAddress are exported from src/validation/index.ts and re-exported from src/index.ts. TypeScript compiles cleanly. EVM validator uses crypto/eip55, Solana validator uses crypto/base58, dispatch uses registries/networks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Address validation test suites with cross-chain mismatch tests</name>
  <files>
    packages/x402check/test/validation/evm-address.test.ts
    packages/x402check/test/validation/solana-address.test.ts
    packages/x402check/test/validation/address.test.ts
  </files>
  <action>
    1. Create directory `packages/x402check/test/validation/` if it doesn't exist.

    2. Create `packages/x402check/test/validation/evm-address.test.ts`:
       Import `{ validateEvmAddress }` from `../../src/validation/evm-address`.

       Test cases:
       a. Valid checksummed addresses (zero issues):
          - '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed' — EIP-55 reference
          - '0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359' — EIP-55 reference
          - '0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB' — EIP-55 reference
          - '0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb' — EIP-55 reference

       b. All-lowercase address (NO_EVM_CHECKSUM warning):
          - '0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed'
          - Should have 0 errors, 1 warning with code NO_EVM_CHECKSUM
          - Warning fix should contain the correct checksummed address

       c. All-uppercase address (no issues):
          - '0x52908400098527886E0F7030069857D2E4169EE7'
          - Should have 0 errors, 0 warnings

       d. Bad checksum (BAD_EVM_CHECKSUM warning):
          - '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAeD' (last char wrong case)
          - Should have 0 errors, 1 warning with code BAD_EVM_CHECKSUM
          - Warning fix should contain the correct checksummed address

       e. Invalid format (INVALID_EVM_ADDRESS error):
          - '5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed' (no 0x prefix)
          - '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeA' (too short, 41 chars)
          - '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed00' (too long, 44 chars)
          - '0xGGGGb6053F3E94C9b9A09f33669435E7Ef1BeAed' (invalid hex chars)
          - Each should have 1 error with code INVALID_EVM_ADDRESS

       f. Empty string (INVALID_EVM_ADDRESS error):
          - '' should produce INVALID_EVM_ADDRESS error

    3. Create `packages/x402check/test/validation/solana-address.test.ts`:
       Import `{ validateSolanaAddress }` from `../../src/validation/solana-address`.

       Test cases:
       a. Valid Solana addresses (zero issues):
          - '11111111111111111111111111111111' (system program, all zeros)
          - 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' (SPL Token program)

       b. Invalid Base58 characters (INVALID_SOLANA_ADDRESS error):
          - 'invalid!@#$%' (special chars)
          - '0OIl' (excluded Base58 chars: 0, O, I, l)

       c. Too short (INVALID_SOLANA_ADDRESS error):
          - 'abc' (less than 32 chars)

       d. Too long (INVALID_SOLANA_ADDRESS error):
          - Repeat valid chars beyond 44 characters

       e. Valid Base58 but wrong decoded length:
          - Find a Base58 string that is 32-44 chars but decodes to != 32 bytes
          - E.g., 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' (34 a's) — test that decoded length is checked
          - Note: This test may need adjustment based on actual decode length. Write the test to verify the code catches wrong length, even if you need to try a few inputs.

       f. Empty string (INVALID_SOLANA_ADDRESS error):
          - '' should produce INVALID_SOLANA_ADDRESS error (fails regex)

    4. Create `packages/x402check/test/validation/address.test.ts`:
       Import `{ validateAddress }` from `../../src/validation/address`.

       Test cases:
       a. Valid EVM address on EVM network (zero issues):
          - validateAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed', 'eip155:8453', 'accepts[0].payTo')
          - Should return zero errors

       b. Valid Solana address on Solana network (zero issues):
          - validateAddress('11111111111111111111111111111111', 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', 'accepts[0].payTo')
          - Should return zero errors

       c. EVM address on Solana network (error — cross-chain mismatch):
          - validateAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed', 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', 'accepts[0].payTo')
          - Should have at least 1 error (Solana validator rejects 0x-prefixed address)
          - Error code should be INVALID_SOLANA_ADDRESS

       d. Solana address on EVM network (error — cross-chain mismatch):
          - validateAddress('11111111111111111111111111111111', 'eip155:8453', 'accepts[0].payTo')
          - Should have at least 1 error (EVM validator rejects non-0x address)
          - Error code should be INVALID_EVM_ADDRESS

       e. Stellar namespace accepts any address (zero issues):
          - validateAddress('GBDEVU63Y6NTHJQQZIKVTC23NWLQVP3WJ2RI2OTSJTNYOIGICST6DUXR', 'stellar:pubnet', 'accepts[0].payTo')
          - Should return zero issues

       f. Aptos namespace accepts any address (zero issues):
          - validateAddress('0x1', 'aptos:1', 'accepts[0].payTo')
          - Should return zero issues

       g. Unknown namespace returns empty (no issues):
          - validateAddress('someaddress', 'bitcoin:mainnet', 'accepts[0].payTo')
          - Should return zero issues (unknown namespace handling is Phase 8's job)

       h. Invalid CAIP-2 network returns empty (no issues):
          - validateAddress('someaddress', 'not-valid-caip2', 'accepts[0].payTo')
          - Should return zero issues (network format errors are Phase 8's job)

       i. EVM address on unknown EVM network still validates:
          - validateAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed', 'eip155:999999', 'accepts[0].payTo')
          - Should return zero errors (valid EVM address, unknown but valid eip155 network)

    Run tests with `cd packages/x402check && pnpm test` and ensure all pass.
  </action>
  <verify>
    Run `cd packages/x402check && pnpm test` — ALL tests pass (existing Phase 6 tests + crypto tests + validation tests).
    Cross-chain mismatch tests specifically pass (EVM on Solana = error, Solana on EVM = error).
    EIP-55 checksum warnings (not errors) for bad checksum and no checksum.
    Stellar and Aptos namespaces accept any address.
  </verify>
  <done>
    All address validation tests pass. EVM checksum validation produces warnings (not errors) for bad/missing checksums and errors for format violations. Solana validates Base58 + 32-byte length. Cross-chain mismatches are caught by dispatch. Stellar/Aptos accept any address. Full test suite (Phase 6 + Phase 7) passes.
  </done>
</task>

</tasks>

<verification>
1. `cd packages/x402check && pnpm exec tsc --noEmit` — zero TypeScript errors
2. `cd packages/x402check && pnpm test` — all tests pass (Phase 6 + Phase 7)
3. Cross-chain mismatch: EVM address on Solana network produces error
4. Cross-chain mismatch: Solana address on EVM network produces error
5. Checksum: '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed' produces zero issues
6. Checksum: lowercase version produces NO_EVM_CHECKSUM warning
7. Checksum: wrong-case version produces BAD_EVM_CHECKSUM warning
8. Solana: '11111111111111111111111111111111' produces zero issues
9. Dispatch: stellar and aptos namespaces return empty array
10. `import { validateAddress, keccak256, decodeBase58 } from './src/index'` — resolves correctly
</verification>

<success_criteria>
- validateEvmAddress correctly implements EIP-55 checksum as warning, format as error
- validateSolanaAddress correctly validates Base58 + 32-byte decoded length
- validateAddress dispatches by CAIP-2 namespace (eip155 -> EVM, solana -> Solana)
- Cross-chain mismatches are caught (EVM address on Solana = error, Solana on EVM = error)
- Stellar and Aptos accept any address (deep validation deferred)
- src/index.ts exports crypto and validation modules
- All Phase 6 + Phase 7 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-crypto-vendoring-and-address-validation/07-02-SUMMARY.md`
</output>
