---
phase: 07-crypto-vendoring-and-address-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/x402check/package.json
  - packages/x402check/src/types/errors.ts
  - packages/x402check/src/crypto/keccak256.ts
  - packages/x402check/src/crypto/base58.ts
  - packages/x402check/src/crypto/eip55.ts
  - packages/x402check/src/crypto/index.ts
  - packages/x402check/test/crypto/keccak256.test.ts
  - packages/x402check/test/crypto/base58.test.ts
  - packages/x402check/test/crypto/eip55.test.ts
autonomous: true

must_haves:
  truths:
    - "keccak256('') returns 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470' (Keccak-256, NOT SHA-3)"
    - "keccak256('hello world') returns '47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad'"
    - "decodeBase58('11111111111111111111111111111111') returns 32 bytes of all zeros"
    - "EIP-55 toChecksumAddress produces correct mixed-case for reference addresses"
    - "isValidChecksum returns true for correctly checksummed addresses and false for incorrectly checksummed"
    - "NO_EVM_CHECKSUM error code exists in ErrorCode and ErrorMessages"
    - "All crypto primitives have zero runtime dependencies (only devDependencies)"
  artifacts:
    - path: "packages/x402check/src/crypto/keccak256.ts"
      provides: "keccak256(input: string | Uint8Array): string — hex output, no 0x prefix"
      exports: ["keccak256"]
    - path: "packages/x402check/src/crypto/base58.ts"
      provides: "decodeBase58(input: string): Uint8Array — preserves leading zeros"
      exports: ["decodeBase58"]
    - path: "packages/x402check/src/crypto/eip55.ts"
      provides: "toChecksumAddress(address: string): string and isValidChecksum(address: string): boolean"
      exports: ["toChecksumAddress", "isValidChecksum"]
    - path: "packages/x402check/src/crypto/index.ts"
      provides: "Barrel re-exports for all crypto modules"
    - path: "packages/x402check/src/types/errors.ts"
      provides: "NO_EVM_CHECKSUM error code added to ErrorCode and ErrorMessages"
      contains: "NO_EVM_CHECKSUM"
  key_links:
    - from: "packages/x402check/src/crypto/eip55.ts"
      to: "packages/x402check/src/crypto/keccak256.ts"
      via: "import { keccak256 }"
      pattern: "import.*keccak256.*from.*keccak256"
    - from: "packages/x402check/src/crypto/keccak256.ts"
      to: "@noble/hashes/sha3"
      via: "import { keccak_256 }"
      pattern: "import.*keccak_256.*from.*@noble/hashes"
    - from: "packages/x402check/src/crypto/base58.ts"
      to: "@scure/base"
      via: "import { base58 }"
      pattern: "import.*base58.*from.*@scure/base"
---

<objective>
Install audited crypto libraries and create wrapper modules for keccak256, Base58, and EIP-55 checksum, with comprehensive canary tests proving correctness against reference test vectors.

Purpose: Phase 7 requires vendored (tree-shakeable devDep) crypto primitives that downstream address validation (Plan 02) and checksum verification depend on. These wrappers isolate the SDK from library API changes and provide the exact signatures needed.

Output: Three crypto modules (keccak256, base58, eip55) with barrel export, NO_EVM_CHECKSUM error code added, and test suites with canary tests proving Keccak-256 (not SHA-3) and Base58 leading-zero preservation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-crypto-vendoring-and-address-validation/07-RESEARCH.md

@packages/x402check/package.json
@packages/x402check/tsconfig.json
@packages/x402check/vitest.config.ts
@packages/x402check/src/types/errors.ts
@packages/x402check/src/crypto/.gitkeep
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install crypto libraries and create keccak256 + Base58 wrappers</name>
  <files>
    packages/x402check/package.json
    packages/x402check/src/types/errors.ts
    packages/x402check/src/crypto/keccak256.ts
    packages/x402check/src/crypto/base58.ts
    packages/x402check/src/crypto/eip55.ts
    packages/x402check/src/crypto/index.ts
  </files>
  <action>
    1. Install `@noble/hashes` and `@scure/base` as devDependencies in packages/x402check:
       ```
       cd packages/x402check && pnpm add -D @noble/hashes @scure/base
       ```

    2. Remove `packages/x402check/src/crypto/.gitkeep` (directory will have real files).

    3. Create `packages/x402check/src/crypto/keccak256.ts`:
       - Import `keccak_256` from `@noble/hashes/sha3` (NOT from sha3 directly — the Keccak variant is at this path)
       - Export function `keccak256(input: string | Uint8Array): string`
       - If input is string, convert to Uint8Array via `new TextEncoder().encode(input)`
       - Hash with `keccak_256(bytes)`
       - Convert result to lowercase hex string (no 0x prefix) using `Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('')`
       - Function is ~10 lines total

    4. Create `packages/x402check/src/crypto/base58.ts`:
       - Import `base58` from `@scure/base`
       - Export function `decodeBase58(input: string): Uint8Array`
       - Wraps `base58.decode(input)` in try/catch
       - On error, throw `new Error('Invalid Base58: ...')` with original error message
       - Function is ~10 lines total

    5. Create `packages/x402check/src/crypto/eip55.ts`:
       - Import `keccak256` from `./keccak256`
       - Export function `toChecksumAddress(address: string): string`:
         - Takes a 42-char hex address (0x-prefixed)
         - Lowercase the hex part (slice(2).toLowerCase())
         - Hash the lowercase hex with keccak256
         - For each character in the hex part (40 chars):
           - If char is a-f AND hash nibble (parsed as int) >= 8: uppercase it
           - Otherwise: keep lowercase
         - Return '0x' + result
       - Export function `isValidChecksum(address: string): boolean`:
         - Return `address === toChecksumAddress(address)`
         - Note: all-lowercase and all-uppercase addresses will NOT match their checksum version (this is intentional — caller distinguishes no-checksum from bad-checksum)

    6. Create `packages/x402check/src/crypto/index.ts`:
       ```typescript
       // Crypto primitives barrel export
       export { keccak256 } from './keccak256'
       export { decodeBase58 } from './base58'
       export { toChecksumAddress, isValidChecksum } from './eip55'
       ```

    7. Add `NO_EVM_CHECKSUM` to `packages/x402check/src/types/errors.ts`:
       - Add to ErrorCode object: `NO_EVM_CHECKSUM: 'NO_EVM_CHECKSUM',` in the "Address errors" section (after BAD_EVM_CHECKSUM)
       - Add to ErrorMessages: `NO_EVM_CHECKSUM: 'EVM address is all-lowercase with no checksum protection',` in the "Address errors" section
       - This brings error code count from 27 to 28

    IMPORTANT: Use `@noble/hashes/sha3` for the import path — that is where keccak_256 lives. Do NOT use `@noble/hashes/keccak` or `@noble/hashes` directly.
    IMPORTANT: The eip55.ts module must NOT compare with `===` using `address.toLowerCase()` for the all-lowercase check — that is the caller's responsibility. eip55 only does checksum computation and comparison.
  </action>
  <verify>
    Run `cd packages/x402check && pnpm exec tsc --noEmit` — no TypeScript errors.
    Verify @noble/hashes and @scure/base appear in devDependencies (not dependencies) in package.json.
  </verify>
  <done>
    keccak256, decodeBase58, toChecksumAddress, and isValidChecksum are exported from src/crypto/index.ts. NO_EVM_CHECKSUM error code exists. TypeScript compiles cleanly. Both libraries are devDependencies only.
  </done>
</task>

<task type="auto">
  <name>Task 2: Crypto primitive test suites with canary vectors</name>
  <files>
    packages/x402check/test/crypto/keccak256.test.ts
    packages/x402check/test/crypto/base58.test.ts
    packages/x402check/test/crypto/eip55.test.ts
  </files>
  <action>
    1. Create directory `packages/x402check/test/crypto/` if it doesn't exist.

    2. Create `packages/x402check/test/crypto/keccak256.test.ts`:
       ```
       describe('keccak256', () => {
         // CANARY: Empty string must produce Keccak-256 (NOT SHA-3)
         it('empty string produces Keccak-256 hash (not SHA-3)', () => {
           expect(keccak256('')).toBe('c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470')
         })

         it('empty string does NOT produce SHA-3-256 hash', () => {
           expect(keccak256('')).not.toBe('a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a')
         })

         it('hello world produces correct hash', () => {
           expect(keccak256('hello world')).toBe('47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad')
         })

         it('accepts Uint8Array input', () => {
           const bytes = new TextEncoder().encode('')
           expect(keccak256(bytes)).toBe('c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470')
         })

         it('returns 64-char hex string without 0x prefix', () => {
           const hash = keccak256('test')
           expect(hash).toHaveLength(64)
           expect(hash).toMatch(/^[0-9a-f]{64}$/)
         })
       })
       ```

    3. Create `packages/x402check/test/crypto/base58.test.ts`:
       ```
       describe('decodeBase58', () => {
         // CANARY: All-1s address must produce 32 zero bytes
         it('all-1s Solana address decodes to 32 zero bytes', () => {
           const decoded = decodeBase58('11111111111111111111111111111111')
           expect(decoded.length).toBe(32)
           expect(Array.from(decoded).every(b => b === 0)).toBe(true)
         })

         it('preserves leading zero bytes', () => {
           // Leading '1' chars map to 0x00 bytes
           const decoded = decodeBase58('111abc')
           expect(decoded[0]).toBe(0)
           expect(decoded[1]).toBe(0)
           expect(decoded[2]).toBe(0)
         })

         it('decodes a valid Base58 string', () => {
           const decoded = decodeBase58('2NEpo7TZRRrLZSi2U')
           expect(decoded).toBeInstanceOf(Uint8Array)
           expect(decoded.length).toBeGreaterThan(0)
         })

         it('throws on invalid Base58 characters', () => {
           // 0, O, I, l are not in Base58 alphabet
           expect(() => decodeBase58('0OIl')).toThrow('Invalid Base58')
         })

         it('throws on empty string', () => {
           // Edge case: empty string should be handled
           const decoded = decodeBase58('')
           expect(decoded.length).toBe(0)
         })
       })
       ```
       Note: Adjust the empty string test — @scure/base may return empty Uint8Array or throw. Write the test to match actual behavior: if it returns empty array, use expect(decoded.length).toBe(0); if it throws, use expect(() => ...).toThrow().

    4. Create `packages/x402check/test/crypto/eip55.test.ts`:
       ```
       describe('toChecksumAddress', () => {
         // EIP-55 reference vectors from the specification
         it('produces correct checksum for reference addresses', () => {
           // All caps
           expect(toChecksumAddress('0x52908400098527886E0F7030069857D2E4169EE7'))
             .toBe('0x52908400098527886E0F7030069857D2E4169EE7')

           // All lower
           expect(toChecksumAddress('0xde709f2102306220921060314715629080e2fb77'))
             .toBe('0xde709f2102306220921060314715629080e2fb77')

           // Mixed case - the canonical test
           expect(toChecksumAddress('0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed'))
             .toBe('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed')

           expect(toChecksumAddress('0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359'))
             .toBe('0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359')

           expect(toChecksumAddress('0xdbf03b407c01e7cd3cbea99509d93f8dddc8c6fb'))
             .toBe('0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB')

           expect(toChecksumAddress('0xd1220a0cf47c7b9be7a2e6ba89f429762e7b9adb'))
             .toBe('0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb')
         })
       })

       describe('isValidChecksum', () => {
         it('returns true for correctly checksummed addresses', () => {
           expect(isValidChecksum('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed')).toBe(true)
           expect(isValidChecksum('0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359')).toBe(true)
           expect(isValidChecksum('0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB')).toBe(true)
           expect(isValidChecksum('0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb')).toBe(true)
         })

         it('returns false for incorrectly checksummed addresses', () => {
           // Last char changed from 'd' to 'D'
           expect(isValidChecksum('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAeD')).toBe(false)
         })

         it('returns false for all-lowercase addresses', () => {
           // Lowercase is valid format but does NOT match checksum
           expect(isValidChecksum('0x5aaeb6053f3e94c9b9a09f33669435e7ef1beaed')).toBe(false)
         })

         it('returns false for all-uppercase addresses', () => {
           // Uppercase is valid format but does NOT match checksum (unless it happens to)
           // This specific address: 0x5AAEB6053F3E94C9B9A09F33669435E7EF1BEAED would not match checksum
           expect(isValidChecksum('0x5AAEB6053F3E94C9B9A09F33669435E7EF1BEAED')).toBe(false)
         })
       })
       ```

    IMPORTANT: Import from the src paths relative to the test file:
    - `import { keccak256 } from '../../src/crypto/keccak256'`
    - `import { decodeBase58 } from '../../src/crypto/base58'`
    - `import { toChecksumAddress, isValidChecksum } from '../../src/crypto/eip55'`

    Run tests with `cd packages/x402check && pnpm test` and ensure all pass. If any test fails due to wrong expected value (e.g., empty string Base58 behavior), fix the test expectation to match the actual correct behavior while documenting why.
  </action>
  <verify>
    Run `cd packages/x402check && pnpm test` — ALL tests pass (existing + new crypto tests).
    Canary test for empty string keccak256 specifically passes with the Keccak-256 hash.
    Canary test for all-1s Base58 address specifically passes with 32 zero bytes.
    EIP-55 reference vectors all produce correct checksummed output.
  </verify>
  <done>
    All crypto primitive tests pass. Canary tests prove keccak256 is Keccak-256 (not SHA-3). Base58 preserves leading zeros. EIP-55 checksum produces correct output for all reference vectors. No test failures.
  </done>
</task>

</tasks>

<verification>
1. `cd packages/x402check && pnpm exec tsc --noEmit` — zero TypeScript errors
2. `cd packages/x402check && pnpm test` — all tests pass (existing Phase 6 tests + new crypto tests)
3. `grep '"@noble/hashes"' packages/x402check/package.json` — appears in devDependencies
4. `grep '"@scure/base"' packages/x402check/package.json` — appears in devDependencies
5. `grep 'NO_EVM_CHECKSUM' packages/x402check/src/types/errors.ts` — error code exists
6. `grep '"dependencies"' packages/x402check/package.json` — should NOT exist (zero runtime deps)
</verification>

<success_criteria>
- keccak256('') returns 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
- decodeBase58('11111111111111111111111111111111') returns 32 zero bytes
- toChecksumAddress produces correct EIP-55 output for all reference vectors
- NO_EVM_CHECKSUM error code is defined and has a human-readable message
- @noble/hashes and @scure/base are devDependencies (not dependencies)
- All existing Phase 6 tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-crypto-vendoring-and-address-validation/07-01-SUMMARY.md`
</output>
