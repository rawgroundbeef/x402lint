---
phase: 06-types-detection-normalization
plan: 02
type: execute
wave: 3
depends_on: ["06-01", "06-03"]
files_modified:
  - packages/x402lint/src/detection/detect.ts
  - packages/x402lint/src/detection/guards.ts
  - packages/x402lint/src/detection/normalize.ts
  - packages/x402lint/src/detection/index.ts
  - packages/x402lint/src/index.ts
autonomous: true

must_haves:
  truths:
    - "detect() on a v2 config object returns 'v2'"
    - "detect() on a v1 config returns 'v1'"
    - "detect() on a flat-legacy config returns 'flat-legacy'"
    - "detect() on garbage returns 'unknown'"
    - "detect() with a JSON string input works identically to passing a parsed object"
    - "normalize() on a flat-legacy config returns canonical v2 shape with accepts[], scheme:'exact', CAIP-2 network, and amount field"
    - "normalize() returns null on garbage"
    - "normalize() with a JSON string input works identically to passing a parsed object"
    - "normalize() preserves extra and extensions through transformation"
  artifacts:
    - path: "packages/x402lint/src/detection/guards.ts"
      provides: "Type guard functions: isRecord, isV2Config, isV1Config, isFlatLegacyConfig"
      contains: "config is"
    - path: "packages/x402lint/src/detection/detect.ts"
      provides: "detect() function returning ConfigFormat"
      contains: "detect"
    - path: "packages/x402lint/src/detection/normalize.ts"
      provides: "normalize() function, normalizeV2, normalizeV1ToV2, normalizeFlatToV2"
      contains: "normalize"
    - path: "packages/x402lint/src/detection/index.ts"
      provides: "Re-exports detect and normalize"
  key_links:
    - from: "packages/x402lint/src/detection/detect.ts"
      to: "packages/x402lint/src/detection/guards.ts"
      via: "imports type guards for format detection"
      pattern: "import.*guards"
    - from: "packages/x402lint/src/detection/normalize.ts"
      to: "packages/x402lint/src/detection/detect.ts"
      via: "calls detect() to determine format before normalizing"
      pattern: "import.*detect"
    - from: "packages/x402lint/src/detection/normalize.ts"
      to: "packages/x402lint/src/registries/simple-names.ts"
      via: "uses getCanonicalNetwork for flat-legacy network mapping"
      pattern: "getCanonicalNetwork"
    - from: "packages/x402lint/src/index.ts"
      to: "packages/x402lint/src/detection/index.ts"
      via: "re-export"
      pattern: "export.*from.*detection"
---

<objective>
Implement format detection (detect) and normalization (normalize) -- the two public APIs from this phase that transform any x402 config format into a canonical v2 shape.

Purpose: detect() and normalize() are used by the validate() orchestrator in Phase 8. detect() identifies which format a config uses. normalize() converts any recognized format to canonical v2 shape so validation rules only need to handle one format. Together they satisfy API-02, API-03, API-04, and FMT-01 through FMT-08.

Output: Working detect() and normalize() functions with type guards, exported from the package entry point, with comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-types-detection-normalization/06-RESEARCH.md

# Prior plan outputs (types and registries must be complete)
@.planning/phases/06-types-detection-normalization/06-01-SUMMARY.md
@.planning/phases/06-types-detection-normalization/06-03-SUMMARY.md

@packages/x402lint/src/types/config.ts
@packages/x402lint/src/types/errors.ts
@packages/x402lint/src/types/parse-input.ts
@packages/x402lint/src/registries/networks.ts
@packages/x402lint/src/registries/simple-names.ts
@packages/x402lint/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Type guards and detect() function</name>
  <files>
    packages/x402lint/src/detection/guards.ts
    packages/x402lint/src/detection/detect.ts
  </files>
  <action>
Delete the `.gitkeep` in `src/detection/` first.

**guards.ts** -- Runtime type guard predicates for format detection:

1. `isRecord(value: unknown): value is Record<string, unknown>` -- checks `typeof value === 'object' && value !== null && !Array.isArray(value)`

2. `hasAcceptsArray(config: Record<string, unknown>): boolean` -- checks `'accepts' in config && Array.isArray(config.accepts)`

3. `isV2Config(value: unknown): value is V2Config` -- checks:
   - isRecord(value)
   - hasAcceptsArray(value)
   - `'x402Version' in value && value.x402Version === 2`
   - `'resource' in value` (v2 requires resource at top level)
   Import V2Config from `../types`

4. `isV1Config(value: unknown): value is V1Config` -- checks:
   - isRecord(value)
   - hasAcceptsArray(value)
   - `'x402Version' in value && value.x402Version === 1`
   Import V1Config from `../types`

5. `isFlatLegacyConfig(value: unknown): value is FlatLegacyConfig` -- checks:
   - isRecord(value)
   - NOT hasAcceptsArray (no `accepts` array)
   - Has at least one of: `payTo`, `address`, `payments`, `amount`, `minAmount` with `network` or `chain`
   Import FlatLegacyConfig from `../types`

Export all guards as named exports. Use `unknown` input type for all guards (not `any`).

IMPORTANT: Detection must be ordered from most specific to least specific. v2 check includes `resource`, v1 does not. A config with `accepts` + `x402Version: 2` but no `resource` should still detect as v2 (resource is required but its absence is a validation error, not a detection failure). Actually -- per the research (Pitfall 1: "Use presence of required fields + version number; treat resource as nice-to-have"), detection should NOT require `resource` for v2 detection. Revise `isV2Config`:
   - isRecord(value)
   - hasAcceptsArray(value)
   - `'x402Version' in value && value.x402Version === 2`
   (resource presence is validated later, not used for detection)

This means v2 and v1 are distinguished purely by `x402Version` value (2 vs 1), both requiring `accepts` array.

**detect.ts** -- Main detect() function (API-02):

```typescript
import type { ConfigFormat } from '../types'
import { parseInput } from '../types'
import { isV2Config, isV1Config, isFlatLegacyConfig } from './guards'

export function detect(input: string | object): ConfigFormat {
  const { parsed, error } = parseInput(input)

  if (error) return 'unknown'

  if (isV2Config(parsed)) return 'v2'
  if (isV1Config(parsed)) return 'v1'
  if (isFlatLegacyConfig(parsed)) return 'flat-legacy'

  return 'unknown'
}
```

The function:
1. Accepts `string | object` (API-04)
2. Uses parseInput for JSON string handling (reuses from types)
3. Applies guards in priority order: v2 -> v1 -> flat-legacy -> unknown
4. Returns ConfigFormat literal union
5. Never throws -- returns 'unknown' for any unrecognized input
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/x402lint && pnpm --filter x402lint run typecheck` -- must pass.
  </verify>
  <done>
Type guards correctly identify v2 (accepts + x402Version:2), v1 (accepts + x402Version:1), flat-legacy (payTo/address/payments without accepts), and unknown. detect() accepts string | object and never throws.
  </done>
</task>

<task type="auto">
  <name>Task 2: normalize() function with format transformers</name>
  <files>
    packages/x402lint/src/detection/normalize.ts
    packages/x402lint/src/detection/index.ts
    packages/x402lint/src/index.ts
    packages/x402lint/test/detection.test.ts
  </files>
  <action>
**normalize.ts** -- Normalization pipeline (API-03, FMT-05 through FMT-08):

Import types: `NormalizedConfig`, `AcceptsEntry`, `ConfigFormat`, `V2Config`, `V1Config`, `FlatLegacyConfig` from `../types`
Import: `parseInput` from `../types`
Import: `detect` from `./detect`
Import: `getCanonicalNetwork` from `../registries`
Import guards: `isRecord` from `./guards`

1. Main function:

```typescript
export function normalize(input: string | object): NormalizedConfig | null {
  const { parsed, error } = parseInput(input)
  if (error) return null

  const format = detect(parsed)

  switch (format) {
    case 'v2':
      return normalizeV2(parsed as V2Config)
    case 'v1':
      return normalizeV1ToV2(parsed as V1Config)
    case 'flat-legacy':
      return normalizeFlatToV2(parsed as FlatLegacyConfig)
    case 'unknown':
      return null
    default: {
      const _exhaustive: never = format
      return _exhaustive
    }
  }
}
```

2. `normalizeV2(config: V2Config): NormalizedConfig` -- FMT-07 (pass-through):
   - Return a NEW object (do not return the original reference) with:
     - `x402Version: 2`
     - `accepts: config.accepts` (shallow copy the array: `[...config.accepts]`)
     - `resource: config.resource` (pass through)
     - `error: config.error` (pass through if present)
     - `extensions: config.extensions` (FMT-08: preserve extensions)
   - Do NOT include undefined fields in the output (use conditional spread or explicit checks)

3. `normalizeV1ToV2(config: V1Config): NormalizedConfig` -- FMT-06:
   - Map each accepts entry: `maxAmountRequired` -> `amount`
   - If per-entry `resource` exists on any entry, use the first one as top-level `resource`
   - Return:
     - `x402Version: 2`
     - `accepts`: mapped entries with `amount` instead of `maxAmountRequired`, `resource` removed from entries
     - `resource`: first entry's resource (if any)
     - `error: config.error`
     - `extensions: config.extensions` (FMT-08)

4. `normalizeFlatToV2(config: FlatLegacyConfig): NormalizedConfig` -- FMT-05:
   - Determine recipient: `config.payTo ?? config.address ?? ''`
   - Determine amount: `config.amount ?? config.minAmount ?? ''`
   - Determine network: Try `config.network ?? config.chain ?? ''`, then if result is not valid CAIP-2, try `getCanonicalNetwork(result)` to map simple name to CAIP-2. If mapping fails, keep the original value (validation will catch it later).
   - Determine asset: `config.currency ?? config.asset ?? ''`
   - Handle `payments` array variant: if `config.payments` is an array, map each entry to an AcceptsEntry. Each payment entry may have different field names (address/payTo, chain/network, etc.). Apply same field mapping logic per entry.
   - If no `payments` array, create single-entry `accepts`:
     ```
     [{
       scheme: 'exact',
       network: mappedNetwork,
       amount: amount,
       asset: asset,
       payTo: recipient,
       ...(config.maxTimeoutSeconds !== undefined ? { maxTimeoutSeconds: config.maxTimeoutSeconds } : {}),
       ...(config.extra !== undefined ? { extra: config.extra } : {}),
     }]
     ```
   - Return:
     - `x402Version: 2`
     - `accepts`: the built array
     - `extensions: config.extensions` (FMT-08)
   - Do NOT include `resource` (flat-legacy has no resource concept)

IMPORTANT: Never mutate the input. Always return new objects. Use the `isRecord` guard when accessing properties of `payments` array entries since they are `Record<string, unknown>`.

**detection/index.ts** -- Barrel re-export:
- `export { detect } from './detect'`
- `export { normalize } from './normalize'`
- `export * from './guards'` (export type guards for downstream use)

**src/index.ts** -- Update entry point:
- Uncomment/add: `export { detect, normalize } from './detection'`
- Keep existing exports for types and registries

**test/detection.test.ts** -- Comprehensive tests:

```typescript
import { describe, it, expect } from 'vitest'
import { detect, normalize } from '../src/index'
import type { NormalizedConfig } from '../src/index'

// ---- detect() tests ----

describe('detect', () => {
  describe('v2 format', () => {
    it('detects v2 config with accepts + x402Version:2 + resource', () => {
      expect(detect({
        x402Version: 2,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef' }],
        resource: { url: 'https://example.com/api' },
      })).toBe('v2')
    })

    it('detects v2 even without resource (resource absence is validation error, not detection)', () => {
      expect(detect({
        x402Version: 2,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef' }],
      })).toBe('v2')
    })

    it('detects v2 from JSON string', () => {
      const json = JSON.stringify({
        x402Version: 2,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef' }],
        resource: { url: 'https://example.com' },
      })
      expect(detect(json)).toBe('v2')
    })
  })

  describe('v1 format', () => {
    it('detects v1 config with accepts + x402Version:1', () => {
      expect(detect({
        x402Version: 1,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', maxAmountRequired: '100', asset: '0xabc', payTo: '0xdef' }],
      })).toBe('v1')
    })
  })

  describe('flat-legacy format', () => {
    it('detects flat config with payTo + amount + network', () => {
      expect(detect({
        payTo: '0xabc',
        amount: '100',
        network: 'base',
      })).toBe('flat-legacy')
    })

    it('detects flat config with address + minAmount + chain', () => {
      expect(detect({
        address: '0xabc',
        minAmount: '100',
        chain: 'base',
      })).toBe('flat-legacy')
    })

    it('detects flat config with payments array', () => {
      expect(detect({
        payments: [{ address: '0xabc', amount: '100', chain: 'base' }],
      })).toBe('flat-legacy')
    })
  })

  describe('unknown format', () => {
    it('returns unknown for empty object', () => {
      expect(detect({})).toBe('unknown')
    })

    it('returns unknown for invalid JSON string', () => {
      expect(detect('not json')).toBe('unknown')
    })

    it('returns unknown for array', () => {
      expect(detect('[]')).toBe('unknown')
    })

    it('returns unknown for null-ish JSON', () => {
      expect(detect('null')).toBe('unknown')
    })

    it('returns unknown for number', () => {
      expect(detect('42')).toBe('unknown')
    })
  })
})

// ---- normalize() tests ----

describe('normalize', () => {
  describe('v2 pass-through', () => {
    it('passes v2 config through with new object', () => {
      const input = {
        x402Version: 2 as const,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef', maxTimeoutSeconds: 30 }],
        resource: { url: 'https://example.com/api' },
        extensions: { custom: true },
      }
      const result = normalize(input)
      expect(result).not.toBeNull()
      expect(result!.x402Version).toBe(2)
      expect(result!.accepts).toHaveLength(1)
      expect(result!.accepts[0]!.amount).toBe('100')
      expect(result!.resource).toEqual({ url: 'https://example.com/api' })
      expect(result!.extensions).toEqual({ custom: true })
      // Should be a new object, not same reference
      expect(result).not.toBe(input)
    })
  })

  describe('v1 to v2', () => {
    it('maps maxAmountRequired to amount', () => {
      const result = normalize({
        x402Version: 1,
        accepts: [{
          scheme: 'exact',
          network: 'eip155:8453',
          maxAmountRequired: '500',
          asset: '0xabc',
          payTo: '0xdef',
          resource: { url: 'https://example.com' },
        }],
      })
      expect(result).not.toBeNull()
      expect(result!.x402Version).toBe(2)
      expect(result!.accepts[0]!.amount).toBe('500')
      expect(result!.accepts[0]).not.toHaveProperty('maxAmountRequired')
    })

    it('lifts per-entry resource to top level', () => {
      const result = normalize({
        x402Version: 1,
        accepts: [{
          scheme: 'exact',
          network: 'eip155:8453',
          maxAmountRequired: '500',
          asset: '0xabc',
          payTo: '0xdef',
          resource: { url: 'https://example.com' },
        }],
      })
      expect(result!.resource).toEqual({ url: 'https://example.com' })
    })

    it('preserves extensions', () => {
      const result = normalize({
        x402Version: 1,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', maxAmountRequired: '100', asset: '0xabc', payTo: '0xdef' }],
        extensions: { facilitator: 'custom' },
      })
      expect(result!.extensions).toEqual({ facilitator: 'custom' })
    })
  })

  describe('flat-legacy to v2', () => {
    it('wraps flat config in accepts array with scheme:exact', () => {
      const result = normalize({
        payTo: '0xdef',
        amount: '100',
        network: 'eip155:8453',
        asset: '0xabc',
      })
      expect(result).not.toBeNull()
      expect(result!.x402Version).toBe(2)
      expect(result!.accepts).toHaveLength(1)
      expect(result!.accepts[0]!.scheme).toBe('exact')
      expect(result!.accepts[0]!.payTo).toBe('0xdef')
      expect(result!.accepts[0]!.amount).toBe('100')
      expect(result!.accepts[0]!.network).toBe('eip155:8453')
    })

    it('maps simple chain name to CAIP-2', () => {
      const result = normalize({
        payTo: '0xdef',
        amount: '100',
        network: 'base',
        asset: '0xabc',
      })
      expect(result!.accepts[0]!.network).toBe('eip155:8453')
    })

    it('maps legacy field names (address, minAmount, chain, currency)', () => {
      const result = normalize({
        address: '0xdef',
        minAmount: '200',
        chain: 'base',
        currency: '0xabc',
      })
      expect(result!.accepts[0]!.payTo).toBe('0xdef')
      expect(result!.accepts[0]!.amount).toBe('200')
      expect(result!.accepts[0]!.network).toBe('eip155:8453')
      expect(result!.accepts[0]!.asset).toBe('0xabc')
    })

    it('preserves extra and extensions', () => {
      const result = normalize({
        payTo: '0xdef',
        amount: '100',
        network: 'eip155:8453',
        asset: '0xabc',
        extra: { domain: 'test.com' },
        extensions: { custom: true },
      })
      expect(result!.accepts[0]!.extra).toEqual({ domain: 'test.com' })
      expect(result!.extensions).toEqual({ custom: true })
    })

    it('keeps unrecognized network as-is (validation catches it later)', () => {
      const result = normalize({
        payTo: '0xdef',
        amount: '100',
        network: 'unknown-chain',
        asset: '0xabc',
      })
      expect(result!.accepts[0]!.network).toBe('unknown-chain')
    })
  })

  describe('unknown/garbage', () => {
    it('returns null for garbage input', () => {
      expect(normalize({})).toBeNull()
      expect(normalize('not json')).toBeNull()
      expect(normalize('null')).toBeNull()
      expect(normalize('42')).toBeNull()
    })
  })

  describe('string input (API-04)', () => {
    it('normalizes JSON string identically to object', () => {
      const obj = {
        x402Version: 2,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef' }],
        resource: { url: 'https://example.com' },
      }
      const fromObj = normalize(obj)
      const fromStr = normalize(JSON.stringify(obj))
      expect(fromObj).toEqual(fromStr)
    })
  })
})
```
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/x402lint && pnpm --filter x402lint run typecheck` -- must pass.
Run `cd /Users/rawgroundbeef/Projects/x402lint && pnpm --filter x402lint run test` -- all tests pass including detection.test.ts (expect 25+ test cases).
  </verify>
  <done>
detect() returns 'v2', 'v1', 'flat-legacy', or 'unknown' based on structural markers (FMT-01 through FMT-04). normalize() converts any format to canonical v2 shape (FMT-05 through FMT-08). Both accept string | object (API-04). Extra and extensions preserved (FMT-08). Comprehensive test suite covers all format combinations, edge cases, and string/object parity.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter x402lint run typecheck` passes
2. `pnpm --filter x402lint run test` passes -- all 25+ test cases in detection.test.ts
3. detect() handles all 4 format cases correctly
4. normalize() transforms flat-legacy to v2 with accepts[], scheme:"exact", mapped CAIP-2 network
5. normalize() transforms v1 to v2 with maxAmountRequired -> amount mapping
6. normalize() passes v2 through as new object
7. normalize() returns null for unknown format
8. Both functions accept string and object inputs identically (API-04)
9. Extra and extensions preserved through all normalization paths (FMT-08)
</verification>

<success_criteria>
- API-02: detect() returns ConfigFormat union
- API-03: normalize() converts any format to canonical v2 or null
- API-04: Both accept string | object
- API-07: Named exports only
- FMT-01: detect v2 (accepts + x402Version:2)
- FMT-02: detect v1 (accepts + x402Version:1)
- FMT-03: detect flat-legacy (root-level payTo/address/payments)
- FMT-04: detect unknown for unrecognized shapes
- FMT-05: normalize flat-legacy to v2 (wrap in accepts[], map fields, scheme:"exact")
- FMT-06: normalize v1 to v2 (maxAmountRequired -> amount, per-entry resource -> top-level)
- FMT-07: normalize v2 pass-through (new object)
- FMT-08: preserve extra and extensions through normalization
</success_criteria>

<output>
After completion, create `.planning/phases/06-types-detection-normalization/06-02-SUMMARY.md`
</output>
