---
phase: 11-manifest-types-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/x402check/src/types/manifest.ts
  - packages/x402check/src/types/config.ts
  - packages/x402check/src/types/errors.ts
  - packages/x402check/src/types/index.ts
  - packages/x402check/src/detection/guards.ts
  - packages/x402check/src/detection/detect.ts
  - packages/x402check/src/detection/normalize.ts
  - packages/x402check/src/detection/index.ts
  - packages/x402check/src/index.ts
autonomous: true

must_haves:
  truths:
    - "detect() returns 'manifest' for valid manifest JSON with endpoints collection"
    - "detect() continues to return 'v2', 'v1', and 'unknown' for single configs (no regressions)"
    - "isManifestConfig() type guard correctly identifies manifests and rejects non-manifests"
    - "ManifestConfig type defines canonical shape with service metadata and endpoints Record"
    - "TypeScript compiles without errors after ConfigFormat extension to include 'manifest'"
  artifacts:
    - path: "packages/x402check/src/types/manifest.ts"
      provides: "ManifestConfig, ServiceMetadata, ServiceContact, ManifestValidationResult types"
      min_lines: 40
    - path: "packages/x402check/src/types/config.ts"
      provides: "Extended ConfigFormat union including 'manifest'"
      contains: "'manifest'"
    - path: "packages/x402check/src/types/errors.ts"
      provides: "Manifest-specific error codes"
      contains: "MANIFEST"
    - path: "packages/x402check/src/detection/guards.ts"
      provides: "isManifestConfig() type guard"
      exports: ["isManifestConfig"]
    - path: "packages/x402check/src/detection/detect.ts"
      provides: "detect() with manifest-first detection order"
      contains: "isManifestConfig"
  key_links:
    - from: "packages/x402check/src/types/manifest.ts"
      to: "packages/x402check/src/types/config.ts"
      via: "imports V2Config for endpoints Record value type"
      pattern: "import.*V2Config.*from.*config"
    - from: "packages/x402check/src/detection/detect.ts"
      to: "packages/x402check/src/detection/guards.ts"
      via: "imports and calls isManifestConfig before isV2Config"
      pattern: "isManifestConfig\\(parsed\\)"
    - from: "packages/x402check/src/detection/normalize.ts"
      to: "packages/x402check/src/detection/detect.ts"
      via: "manifest case in switch handles new ConfigFormat variant"
      pattern: "case 'manifest'"
---

<objective>
Define the canonical manifest types and extend detection to recognize manifests before single v2 configs.

Purpose: Phase 11 foundation -- all downstream manifest features (validation, CLI, website) depend on these types and the detection logic being correct. The critical risk is detection order: manifest MUST be checked before v2 since manifests may contain x402Version: 2.

Output: ManifestConfig type, extended ConfigFormat, isManifestConfig() guard, updated detect() with correct ordering, manifest error codes, and compile-clean codebase.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-manifest-types-detection/11-RESEARCH.md

@packages/x402check/src/types/config.ts
@packages/x402check/src/types/validation.ts
@packages/x402check/src/types/errors.ts
@packages/x402check/src/types/index.ts
@packages/x402check/src/detection/guards.ts
@packages/x402check/src/detection/detect.ts
@packages/x402check/src/detection/normalize.ts
@packages/x402check/src/detection/index.ts
@packages/x402check/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Manifest types, extended ConfigFormat, and error codes</name>
  <files>
    packages/x402check/src/types/manifest.ts
    packages/x402check/src/types/config.ts
    packages/x402check/src/types/errors.ts
    packages/x402check/src/types/index.ts
  </files>
  <action>
    1. Create `src/types/manifest.ts` with these interfaces:

    **ServiceContact** — optional contact info:
    - `name?: string`
    - `email?: string`
    - `url?: string`

    **ServiceMetadata** — optional service-level metadata:
    - `name?: string`
    - `description?: string`
    - `version?: string`
    - `url?: string`
    - `contact?: ServiceContact`

    **ManifestConfig** — canonical manifest shape:
    - `x402Version?: 2` (optional at manifest level, per research decision)
    - `service?: ServiceMetadata`
    - `endpoints: Record<string, V2Config>` (keyed by endpoint ID, values are V2Config from config.ts)
    - `extensions?: Record<string, unknown>`

    **ManifestValidationResult** — for Phase 13 to consume:
    - `valid: boolean`
    - `errors: ValidationIssue[]` (manifest-level)
    - `warnings: ValidationIssue[]` (manifest-level)
    - `endpointResults: Map<string, ValidationResult>` (per-endpoint)

    Import V2Config from './config' and ValidationIssue/ValidationResult from './validation'.

    2. In `src/types/config.ts`, change ConfigFormat from:
    `export type ConfigFormat = 'v2' | 'v1' | 'unknown'`
    to:
    `export type ConfigFormat = 'manifest' | 'v2' | 'v1' | 'unknown'`

    Put 'manifest' first in the union to signal it should be checked first.

    3. In `src/types/errors.ts`, add manifest-specific error codes to the ErrorCode const BEFORE the warning codes section:

    ```
    // Manifest errors
    MISSING_ENDPOINTS: 'MISSING_ENDPOINTS',
    INVALID_ENDPOINTS: 'INVALID_ENDPOINTS',
    EMPTY_ENDPOINTS: 'EMPTY_ENDPOINTS',
    INVALID_ENDPOINT_CONFIG: 'INVALID_ENDPOINT_CONFIG',
    WILD_MANIFEST_ARRAY_FORMAT: 'WILD_MANIFEST_ARRAY_FORMAT',
    WILD_MANIFEST_NESTED_FORMAT: 'WILD_MANIFEST_NESTED_FORMAT',
    WILD_MANIFEST_NAME_PROMOTED: 'WILD_MANIFEST_NAME_PROMOTED',
    ```

    Add corresponding messages to ErrorMessages:
    - MISSING_ENDPOINTS: 'Manifest must have an endpoints field'
    - INVALID_ENDPOINTS: 'endpoints must be a Record (object) mapping IDs to v2 configs'
    - EMPTY_ENDPOINTS: 'Manifest has no endpoints defined'
    - INVALID_ENDPOINT_CONFIG: 'Endpoint config is not a valid v2 PaymentRequired object'
    - WILD_MANIFEST_ARRAY_FORMAT: 'Detected non-standard array format, normalized to endpoints collection'
    - WILD_MANIFEST_NESTED_FORMAT: 'Detected non-standard nested service format, normalized to endpoints collection'
    - WILD_MANIFEST_NAME_PROMOTED: 'Top-level name field promoted to service.name'

    4. In `src/types/index.ts`, add:
    `export * from './manifest'`

    Keep it after the existing exports.
  </action>
  <verify>
    Run `pnpm --filter x402check exec tsc --noEmit` to confirm TypeScript compiles without errors.
    The exhaustive switch in normalize.ts WILL fail at this point (expected -- Task 2 fixes it). If tsc fails ONLY on the exhaustive check in normalize.ts, that confirms ConfigFormat was correctly extended.
  </verify>
  <done>
    ManifestConfig, ServiceMetadata, ServiceContact, and ManifestValidationResult types exist and are exported. ConfigFormat includes 'manifest'. Seven manifest error codes with messages exist. TypeScript compilation fails ONLY on the exhaustive switch in normalize.ts (expected, fixed in Task 2).
  </done>
</task>

<task type="auto">
  <name>Task 2: Manifest type guard, detection order, and normalize switch</name>
  <files>
    packages/x402check/src/detection/guards.ts
    packages/x402check/src/detection/detect.ts
    packages/x402check/src/detection/normalize.ts
    packages/x402check/src/detection/index.ts
    packages/x402check/src/index.ts
  </files>
  <action>
    1. In `src/detection/guards.ts`, add the `isManifestConfig` type guard function:

    ```typescript
    import type { ManifestConfig } from '../types'
    ```
    (Add ManifestConfig to the existing import from '../types')

    ```typescript
    /**
     * Type guard for manifest config (collection of v2 endpoints)
     * Checks for endpoints collection structure only -- deep validation happens in validateManifest()
     * MUST be checked before isV2Config() since manifests may have x402Version: 2
     */
    export function isManifestConfig(value: unknown): value is ManifestConfig {
      if (!isRecord(value)) return false
      if (!('endpoints' in value)) return false
      if (!isRecord(value.endpoints)) return false

      // Verify endpoint values look like v2 configs (structural, not deep)
      // Empty endpoints ({}) is valid -- allows manifest initialization
      const endpoints = value.endpoints as Record<string, unknown>
      for (const key in endpoints) {
        const endpoint = endpoints[key]
        if (!isRecord(endpoint)) return false
        if (!hasAcceptsArray(endpoint)) return false
      }

      return true
    }
    ```

    Key points:
    - Keep guard SHALLOW -- only check structure, not field values
    - Empty endpoints `{}` returns true (valid empty manifest)
    - Each non-empty endpoint must be an object with an accepts array
    - Do NOT check x402Version (it's optional on manifests)

    2. In `src/detection/detect.ts`, add isManifestConfig to imports and insert manifest check BEFORE v2:

    Update import line to: `import { isV2Config, isV1Config, isManifestConfig } from './guards'`

    Update the detect function body to check manifest FIRST:
    ```typescript
    if (isManifestConfig(parsed)) return 'manifest'  // MUST be first
    if (isV2Config(parsed)) return 'v2'
    if (isV1Config(parsed)) return 'v1'
    ```

    Update the JSDoc return type comment to include 'manifest':
    `@returns ConfigFormat literal: 'manifest' | 'v2' | 'v1' | 'unknown'`

    3. In `src/detection/normalize.ts`, add a `'manifest'` case to the switch statement. Manifests don't normalize to NormalizedConfig (they're collections, not single configs), so return null with a comment explaining why:

    ```typescript
    case 'manifest':
      // Manifests are collections, not single configs
      // Use normalizeWildManifest() for wild manifest normalization
      return null
    ```

    Place it before the 'v2' case. This fixes the exhaustive switch compilation error from Task 1.

    4. In `src/detection/index.ts`, add the isManifestConfig export:
    The existing `export * from './guards'` already re-exports everything from guards.ts, so no change needed here. Verify this is the case.

    5. In `src/index.ts` (main entry), no changes needed -- the existing `export * from './types'` and `export { detect, normalize } from './detection'` already cover the new types and updated detection. Verify this.
  </action>
  <verify>
    Run `pnpm --filter x402check exec tsc --noEmit` -- must pass with zero errors.
    Run `pnpm --filter x402check test` -- all existing 217 tests must still pass (no regressions).
    Verify detect() returns 'manifest' for a manifest object by checking the test output (tests added in Plan 02, but existing tests must not break).
  </verify>
  <done>
    isManifestConfig() guard exists and is exported. detect() checks manifest before v2. normalize() handles 'manifest' case (returns null). TypeScript compiles cleanly. All 217 existing tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter x402check exec tsc --noEmit` passes (zero errors)
2. `pnpm --filter x402check test` passes (all 217 existing tests, zero regressions)
3. `ManifestConfig`, `ServiceMetadata`, `ServiceContact`, `ManifestValidationResult` types are importable from `x402check`
4. `isManifestConfig` function is importable from `x402check`
5. `detect()` returns `'manifest'` when given `{ endpoints: { "a": { x402Version: 2, accepts: [...], resource: {...} } } }`
6. `detect()` still returns `'v2'` for standard v2 config objects (no regression)
</verification>

<success_criteria>
- ConfigFormat = 'manifest' | 'v2' | 'v1' | 'unknown'
- ManifestConfig interface with endpoints: Record<string, V2Config>
- isManifestConfig() guard checks endpoints collection structure
- detect() checks manifest BEFORE v2 (critical ordering)
- normalize() switch handles 'manifest' without compilation error
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/11-manifest-types-detection/11-01-SUMMARY.md`
</output>
