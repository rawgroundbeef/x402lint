---
phase: 11-manifest-types-detection
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - packages/x402lint/src/detection/wild-manifest.ts
  - packages/x402lint/src/detection/index.ts
  - packages/x402lint/test/detection.test.ts
  - packages/x402lint/test/manifest.test.ts
autonomous: true

must_haves:
  truths:
    - "Non-standard array-style manifests are detected and normalized to canonical ManifestConfig"
    - "Non-standard nested-service-style manifests are detected and normalized to canonical ManifestConfig"
    - "Wild manifest normalization produces warnings describing each transformation"
    - "Financial data (amounts, addresses, networks) is never modified during normalization"
    - "Endpoint IDs are generated from URL paths when available, with collision handling"
    - "Empty manifests are detected as 'manifest' format"
    - "detect() still returns 'v2' for single v2 configs after manifest guard addition"
  artifacts:
    - path: "packages/x402lint/src/detection/wild-manifest.ts"
      provides: "normalizeWildManifest(), generateStableEndpointId()"
      min_lines: 60
    - path: "packages/x402lint/test/manifest.test.ts"
      provides: "Manifest detection, guard, and wild normalization tests"
      min_lines: 100
    - path: "packages/x402lint/test/detection.test.ts"
      provides: "Extended detection tests including manifest format"
      contains: "manifest"
  key_links:
    - from: "packages/x402lint/src/detection/wild-manifest.ts"
      to: "packages/x402lint/src/types/manifest.ts"
      via: "imports ManifestConfig for return type"
      pattern: "import.*ManifestConfig.*from"
    - from: "packages/x402lint/src/detection/wild-manifest.ts"
      to: "packages/x402lint/src/detection/guards.ts"
      via: "imports isRecord, hasAcceptsArray for structural checks"
      pattern: "import.*isRecord.*from"
    - from: "packages/x402lint/test/manifest.test.ts"
      to: "packages/x402lint/src/index.ts"
      via: "imports detect, isManifestConfig from public API"
      pattern: "import.*from.*src/index"
---

<objective>
Implement wild manifest normalization and comprehensive tests for all manifest detection and normalization logic.

Purpose: MAN-04 requires non-standard "wild" manifests to be recognized and normalized to canonical ManifestConfig shape with warnings. This completes Phase 11 by ensuring the full detection + normalization pipeline works for both canonical and wild manifests, verified by tests.

Output: normalizeWildManifest() function, generateStableEndpointId() helper, comprehensive test suite covering manifest detection, type guard, wild normalization, and regression tests for existing single-config detection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-manifest-types-detection/11-RESEARCH.md
@.planning/phases/11-manifest-types-detection/11-01-SUMMARY.md

@packages/x402lint/src/types/manifest.ts
@packages/x402lint/src/types/config.ts
@packages/x402lint/src/types/errors.ts
@packages/x402lint/src/detection/guards.ts
@packages/x402lint/src/detection/detect.ts
@packages/x402lint/src/detection/normalize.ts
@packages/x402lint/src/detection/index.ts
@packages/x402lint/test/detection.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wild manifest normalization and endpoint ID generation</name>
  <files>
    packages/x402lint/src/detection/wild-manifest.ts
    packages/x402lint/src/detection/index.ts
  </files>
  <action>
    1. Create `src/detection/wild-manifest.ts` with these exports:

    **Interface: WildManifestResult**
    ```typescript
    import type { ManifestConfig } from '../types'
    import type { ValidationIssue } from '../types'

    export interface WildManifestResult {
      manifest: ManifestConfig
      warnings: ValidationIssue[]
    }
    ```

    **Function: generateStableEndpointId(config, index, existingIds)**
    - Takes a v2 config object (typed as Record<string, unknown> since wild configs may not fully match V2Config), an index number, and a Set<string> of existing IDs
    - If the config has `resource.url` that parses as a valid URL, use the pathname:
      - Strip leading/trailing slashes
      - Replace non-alphanumeric chars with dashes
      - Lowercase
      - If pathname is empty string, fall back to `endpoint-${index}`
    - Otherwise, use `endpoint-${index}`
    - Handle collisions: if the generated ID is already in existingIds, append `-2`, `-3`, etc. until unique
    - Add the final ID to existingIds before returning

    **Function: normalizeWildManifest(input: unknown): WildManifestResult | null**
    - Return null if input is not a Record (use isRecord from guards)
    - Return null if input already matches canonical manifest shape (has `endpoints` key that is a Record) -- canonical manifests don't need wild normalization
    - Initialize empty ManifestConfig: `{ endpoints: {} }`
    - Initialize warnings array (use ValidationIssue type with manifest error codes from errors.ts)

    **Detection Pattern 1 -- Array-style manifests:**
    Check for common array field names: `paymentEndpoints`, `payments`, `configs`, `endpoints` (when value is an array, not a Record).
    For the first matching array field found:
    - Iterate the array, calling generateStableEndpointId for each item
    - Add each item as `endpoints[generatedId]` (cast to V2Config -- validation will catch type issues later)
    - Push a warning with code WILD_MANIFEST_ARRAY_FORMAT, field name identifying which field was found, message describing the transformation (e.g., "Detected non-standard array format 'paymentEndpoints', normalized to endpoints collection"), severity 'warning'

    **Detection Pattern 2 -- Nested-service-style manifests:**
    Check if input has a nested object structure where values contain accepts arrays (e.g., `{ "api": { "weather": {accepts: [...]}, "data": {accepts: [...]} } }`).
    Specifically: if input has NO array-style match AND has at least one key whose value is a Record, check if any nested value (at depth 1 or 2) has an `accepts` array.
    - If depth-1 values have accepts arrays directly, use the top-level keys as endpoint IDs
    - If depth-2 (nested within a grouping key), use `groupKey-endpointKey` as IDs
    - Push a warning with code WILD_MANIFEST_NESTED_FORMAT

    **Service metadata extraction:**
    After endpoint detection, extract service metadata:
    - If input has `service` key that is a Record, extract name/description/version/url/contact from it
    - If input has top-level `name` string (and no service.name was found), promote to service.name and push WILD_MANIFEST_NAME_PROMOTED warning
    - If input has top-level `description` string, promote to service.description
    - If input has top-level `version` string, promote to service.version

    **Extensions preservation:**
    If input has `extensions` key that is a Record, copy it to the manifest.

    **Return logic:**
    - If no endpoints were found via any pattern, return null (can't normalize what we can't detect)
    - Otherwise return `{ manifest, warnings }`

    CRITICAL: Never modify financial data. Copy amounts, addresses, networks, assets exactly as found. Do not parse, reformat, or "fix" any values. Just move them into the canonical structure.

    2. In `src/detection/index.ts`, add:
    `export { normalizeWildManifest } from './wild-manifest'`
    `export type { WildManifestResult } from './wild-manifest'`
  </action>
  <verify>
    Run `pnpm --filter x402lint exec tsc --noEmit` -- must compile cleanly.
    Run `pnpm --filter x402lint test` -- existing tests must still pass.
  </verify>
  <done>
    normalizeWildManifest() handles array-style and nested-service-style wild manifests. generateStableEndpointId() generates URL-path-based IDs with collision handling. Both are exported from the detection barrel. Financial data is never modified during normalization. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive manifest detection and normalization tests</name>
  <files>
    packages/x402lint/test/manifest.test.ts
    packages/x402lint/test/detection.test.ts
  </files>
  <action>
    1. Create `test/manifest.test.ts` with comprehensive test coverage.

    Use the same import pattern as existing tests:
    ```typescript
    import { describe, it, expect } from 'vitest'
    import { detect, isManifestConfig } from '../src/index'
    import { normalizeWildManifest } from '../src/detection'
    import type { ManifestConfig, V2Config } from '../src/index'
    ```

    Create a helper function to build a valid V2Config endpoint for reuse across tests:
    ```typescript
    function makeEndpoint(overrides?: Partial<V2Config>): V2Config {
      return {
        x402Version: 2,
        accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef' }],
        resource: { url: 'https://example.com/api' },
        ...overrides,
      }
    }
    ```

    **Test groups:**

    **describe('isManifestConfig'):**
    - Returns true for manifest with single endpoint
    - Returns true for manifest with multiple endpoints
    - Returns true for empty endpoints ({}) -- allows initialization
    - Returns true for manifest with optional service metadata
    - Returns true for manifest with x402Version: 2 at manifest level
    - Returns false for standard v2 config (has accepts at root, not endpoints)
    - Returns false for v1 config
    - Returns false for empty object {}
    - Returns false for array input
    - Returns false for null/undefined
    - Returns false if endpoints is an array (must be Record)
    - Returns false if endpoints is a string
    - Returns false if any endpoint value is not an object
    - Returns false if any endpoint value lacks accepts array

    **describe('detect manifest format'):**
    - Returns 'manifest' for canonical manifest object
    - Returns 'manifest' for manifest JSON string
    - Returns 'manifest' for manifest with x402Version: 2 (does NOT return 'v2')
    - Returns 'manifest' for empty endpoints ({})
    - Returns 'manifest' for manifest with service metadata
    - Returns 'v2' for standard v2 config (no endpoints key, has accepts at root)
    - Returns 'v2' for v2 config that also has non-Record endpoints field (e.g., endpoints as string -- falls through manifest guard)

    **describe('normalizeWildManifest'):**

    **Array-style normalization:**
    - Normalizes { paymentEndpoints: [config1, config2] } to canonical shape
    - Normalizes { payments: [config1] } to canonical shape
    - Normalizes { configs: [config1, config2, config3] } to canonical shape
    - Generates endpoint IDs from resource URLs when available
    - Falls back to endpoint-0, endpoint-1 for configs without resource URLs
    - Handles URL-based ID collisions by appending -2, -3
    - Produces WILD_MANIFEST_ARRAY_FORMAT warning
    - Preserves financial data exactly (amounts, addresses unchanged)

    **Nested-service-style normalization:**
    - Normalizes { weather: config1, data: config2 } to canonical shape with keys as IDs
    - Produces WILD_MANIFEST_NESTED_FORMAT warning

    **Service metadata extraction:**
    - Extracts service metadata from service object
    - Promotes top-level name to service.name with warning
    - Extracts description and version from top level
    - Does not overwrite service.name with top-level name if service.name exists

    **Edge cases:**
    - Returns null for non-object input
    - Returns null for canonical manifest (already has endpoints Record)
    - Returns null for object with no recognizable pattern
    - Preserves extensions from input
    - Does not add undefined fields to service metadata

    2. In existing `test/detection.test.ts`, add a new describe block for manifest detection regression tests:

    ```typescript
    describe('manifest format', () => {
      it('detects manifest with endpoints collection', () => {
        expect(detect({
          endpoints: {
            'api-weather': {
              x402Version: 2,
              accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef' }],
              resource: { url: 'https://example.com/api/weather' },
            }
          }
        })).toBe('manifest')
      })

      it('detects manifest before v2 even with x402Version: 2', () => {
        expect(detect({
          x402Version: 2,
          endpoints: {
            'api-weather': {
              x402Version: 2,
              accepts: [{ scheme: 'exact', network: 'eip155:8453', amount: '100', asset: '0xabc', payTo: '0xdef' }],
              resource: { url: 'https://example.com/api/weather' },
            }
          }
        })).toBe('manifest')
      })

      it('detects empty manifest', () => {
        expect(detect({ endpoints: {} })).toBe('manifest')
      })
    })
    ```

    These supplement the existing v2/v1/unknown tests to prove no regressions occurred.
  </action>
  <verify>
    Run `pnpm --filter x402lint test` -- ALL tests must pass, both new manifest tests and existing 217 tests.
    Run `pnpm --filter x402lint test -- --reporter=verbose 2>&1 | grep -c "PASS\|âœ“"` to count total passing tests. Should be 217 + new manifest tests.
  </verify>
  <done>
    manifest.test.ts has comprehensive coverage of isManifestConfig(), detect() for manifests, normalizeWildManifest() for array-style and nested-service-style formats, service metadata extraction, and edge cases. detection.test.ts has manifest regression tests proving detect() still works for v2/v1/unknown. All tests pass. Total test count increased from 217 to 217 + N new manifest tests.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter x402lint exec tsc --noEmit` passes
2. `pnpm --filter x402lint test` passes (all old + new tests)
3. normalizeWildManifest({ paymentEndpoints: [v2Config] }) returns canonical ManifestConfig with warnings
4. normalizeWildManifest({ weather: v2Config, data: v2Config }) returns canonical ManifestConfig with warnings
5. Financial data is preserved exactly through normalization (amounts, addresses, networks unchanged)
6. generateStableEndpointId generates URL-based IDs and handles collisions
7. detect() returns 'manifest' for all manifest shapes, 'v2' for v2, 'v1' for v1, 'unknown' otherwise
</verification>

<success_criteria>
- normalizeWildManifest() handles array-style and nested-service-style wild manifests
- Each wild normalization produces warnings describing the transformation
- Financial data (amount, payTo, network, asset) is never modified
- Endpoint IDs are URL-path-based when resource URL available, index-based fallback
- Comprehensive test suite covers guards, detection, normalization, and edge cases
- All existing tests continue to pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/11-manifest-types-detection/11-02-SUMMARY.md`
</output>
