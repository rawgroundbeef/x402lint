---
phase: 02-input-proxy
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified: [index.html, input.js]
autonomous: false

must_haves:
  truths:
    - "User can paste URL and submit for validation"
    - "User can paste JSON and submit for validation"
    - "Input auto-detects URL vs JSON (no tabs/toggles)"
    - "Loading state shows during URL fetch"
    - "Config extracted from PAYMENT-REQUIRED header or response body"
    - "Config source displayed in results (header vs body)"
    - "Errors display in results area"
  artifacts:
    - path: "input.js"
      provides: "Input detection, URL fetching, config extraction"
      min_lines: 100
      exports: ["detectInputType", "fetchConfigFromUrl", "extractX402Config"]
    - path: "index.html"
      provides: "Updated UI with smart input and loading states"
      contains: "input.js"
  key_links:
    - from: "index.html"
      to: "input.js"
      via: "script tag"
      pattern: "src=\"input.js\""
    - from: "input.js"
      to: "validator.js"
      via: "validateX402Config call"
      pattern: "validateX402Config"
    - from: "input.js"
      to: "worker proxy"
      via: "fetch call"
      pattern: "workers.dev"
---

<objective>
Add smart input handling with URL fetching via CORS proxy, enabling users to paste either URLs or JSON configs for validation.

Purpose: This completes the input layer, allowing developers to validate configs by either pasting JSON directly or entering the URL of their x402 endpoint. The proxy (from 02-01) enables fetching from any URL.

Output: Enhanced index.html with smart input detection, input.js with URL fetching and config extraction logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-input-proxy/02-RESEARCH.md
@.planning/phases/02-input-proxy/02-CONTEXT.md
@.planning/phases/02-input-proxy/02-01-SUMMARY.md (for proxy URL)
@index.html
@validator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create input.js with fetch and extraction logic</name>
  <files>input.js</files>
  <action>
    Create input.js with the following functions and constants:

    **Constants (top of file):**
    - PROXY_URL: Get deployed URL from 02-01-SUMMARY.md (e.g., 'https://x402-proxy.xxx.workers.dev')
    - FETCH_TIMEOUT_MS: 5000

    **detectInputType(input):**
    - Trim input with .trim()
    - Return 'url' if trimmed.startsWith('http://') OR trimmed.startsWith('https://')
    - Return 'json' otherwise
    - This is the core detection logic - no regex needed, just prefix check

    **fetchConfigFromUrl(url, proxyBaseUrl = PROXY_URL):**
    - Step 1: Validate URL format
      - Wrap `new URL(url)` in try-catch
      - If throws, throw new Error('Invalid URL format')
    - Step 2: Build proxy URL
      - Construct: `${proxyBaseUrl}?url=${encodeURIComponent(url)}`
      - encodeURIComponent handles special chars in target URL
    - Step 3: Fetch with timeout
      - Call fetch(proxyUrl, { signal: AbortSignal.timeout(FETCH_TIMEOUT_MS) })
      - Wrap in try-catch for error handling:
        - If error.name === 'TimeoutError': throw new Error('Request timeout after 5 seconds - Check URL is reachable')
        - If error.name === 'AbortError': throw new Error('Request was cancelled')
        - Otherwise: throw new Error(`Network error: ${error.message}`)
    - Step 4: Check response status
      - If !response.ok AND response.status !== 402: throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      - Note: 402 is expected for x402 endpoints, treat as success
    - Step 5: Extract config
      - Call extractX402Config(response)
      - Return the extraction result object

    **extractX402Config(response):**
    - Priority 1: Check PAYMENT-REQUIRED header (x402 v2 standard)
      - Get header: response.headers.get('PAYMENT-REQUIRED')
      - If header exists:
        - Try base64 decode first: atob(header), then JSON.parse
        - If atob fails, try direct JSON.parse (fallback for non-base64)
        - Return { config: JSON.stringify(parsed, null, 2), source: 'PAYMENT-REQUIRED header', status: response.status }
        - If both decode attempts fail, continue to body fallback (don't error yet)
    - Priority 2: Check response body (v1 compatibility)
      - Check Content-Type: response.headers.get('Content-Type')
      - If Content-Type includes 'application/json':
        - Read body: await response.text()
        - Validate JSON: JSON.parse(bodyText) - this validates, we keep original text
        - Build result: { config: bodyText, source: 'response body', status: response.status }
        - If status !== 402, add warning: `Response status: ${status} - x402 endpoints should return 402 Payment Required`
        - Return result
    - If neither header nor body has config:
      - Throw new Error('No x402 Config Found - Response had no PAYMENT-REQUIRED header or valid JSON body')

    **formatJsonForDisplay(jsonString):**
    - Try: JSON.parse(jsonString), then JSON.stringify(parsed, null, 2)
    - Catch: return original jsonString unchanged
    - Used for pretty-printing pasted JSON

    **handleValidation(inputValue, displayResultsFn, displayErrorFn):**
    - Main entry point called by index.html click handler
    - Detect input type with detectInputType(inputValue)
    - If type === 'url':
      - Fetch config: result = await fetchConfigFromUrl(inputValue)
      - Validate: validationResult = validateX402Config(result.config)
      - Call displayResultsFn with { ...validationResult, source: result.source, warning: result.warning }
    - If type === 'json':
      - Validate directly: validationResult = validateX402Config(inputValue)
      - Call displayResultsFn with { ...validationResult, source: 'direct input' }
    - This function integrates with validator.js by calling validateX402Config()

    Reference Patterns 1, 2, 4 from 02-RESEARCH.md.
    Handle Pitfalls 1 (timeout cleanup), 5 (body already read), 6 (URL validation), 7 (non-JSON response).
  </action>
  <verify>
    File exists: `ls input.js`
    Functions defined: `grep -E "^function (detectInputType|fetchConfigFromUrl|extractX402Config|formatJsonForDisplay|handleValidation)" input.js`
    Uses AbortSignal.timeout: `grep "AbortSignal.timeout" input.js`
    Checks PAYMENT-REQUIRED: `grep "PAYMENT-REQUIRED" input.js`
    Calls validateX402Config: `grep "validateX402Config" input.js`
    Uses encodeURIComponent for proxy URL: `grep "encodeURIComponent" input.js`
    Has PROXY_URL constant: `grep "PROXY_URL" input.js`
  </verify>
  <done>
    input.js contains:
    - PROXY_URL constant with deployed worker URL
    - detectInputType() distinguishing URL (http:/https: prefix) from JSON
    - fetchConfigFromUrl() with URL validation, proxy URL construction using encodeURIComponent, AbortSignal.timeout, and error handling for timeout/abort/network errors
    - extractX402Config() with header-first priority (base64 then direct JSON), body fallback with Content-Type check, and 402 status warning
    - formatJsonForDisplay() for pretty-printing
    - handleValidation() that calls validateX402Config() from validator.js and returns combined results with source info
  </done>
</task>

<task type="auto">
  <name>Task 2: Update index.html with smart input UI</name>
  <files>index.html</files>
  <action>
    Update index.html to implement smart input from CONTEXT.md decisions:

    **Script tags (add before closing body tag, after validator.js):**
    - Add: `<script src="input.js"></script>`
    - Order matters: validator.js first (defines validateX402Config), then input.js (uses it)

    **Input field changes (find existing textarea or create):**
    - Update placeholder text: "Paste a URL or x402 JSON config..."
    - Add id="config-input" if not present
    - Wrap textarea in div.input-wrapper for CSS Grid auto-expand:
      ```html
      <div class="input-wrapper" data-value="">
        <textarea id="config-input" placeholder="Paste a URL or x402 JSON config..."
          oninput="this.parentNode.dataset.value = this.value"></textarea>
      </div>
      ```

    **Button changes (find existing #validate-btn):**
    - Ensure id="validate-btn" is set
    - Original text should be "Validate" or similar

    **Results area (find existing or create):**
    - Ensure div#results exists for validation output
    - Add span.source-info inside results for "Found in: header/body" display
    - Add span.status-warning for non-402 warnings

    **CSS additions (in style tag or linked CSS):**
    ```css
    /* Auto-expand textarea using CSS Grid trick */
    .input-wrapper {
      display: grid;
      min-height: 50px;
      max-height: 300px;
    }
    .input-wrapper::after {
      content: attr(data-value) " ";
      visibility: hidden;
      white-space: pre-wrap;
      grid-area: 1 / 1 / 2 / 2;
      font: inherit;
      padding: 12px;
      border: 1px solid transparent;
    }
    .input-wrapper > textarea {
      resize: none;
      overflow: auto;
      grid-area: 1 / 1 / 2 / 2;
    }

    /* Loading state for button */
    #validate-btn.loading {
      opacity: 0.7;
      cursor: not-allowed;
    }

    /* Input mode visual feedback */
    #config-input.url-mode {
      border-color: #3b82f6; /* blue hint for URL */
    }
    #config-input.invalid-json {
      border-color: #ef4444; /* red hint for invalid */
    }

    /* Source info in results */
    .source-info {
      font-size: 0.875rem;
      color: #6b7280;
      margin-bottom: 8px;
    }
    .status-warning {
      color: #f59e0b;
      font-size: 0.875rem;
    }
    ```

    **JavaScript event handlers (in script tag or inline):**
    ```javascript
    const input = document.getElementById('config-input');
    const button = document.getElementById('validate-btn');
    const results = document.getElementById('results');

    // Click handler with loading state
    button.addEventListener('click', async () => {
      const value = input.value.trim();
      if (!value) return;

      // Disable button, show loading
      button.disabled = true;
      button.classList.add('loading');
      const originalText = button.textContent;
      button.textContent = 'Validating...';

      try {
        await handleValidation(value, displayResults, displayError);
      } catch (error) {
        displayError(error.message);
      } finally {
        // Always re-enable button
        button.disabled = false;
        button.classList.remove('loading');
        button.textContent = originalText;
      }
    });

    // Paste handler - auto-format JSON
    input.addEventListener('paste', () => {
      setTimeout(() => {
        const value = input.value.trim();
        if (!value.startsWith('http://') && !value.startsWith('https://')) {
          try {
            const formatted = formatJsonForDisplay(value);
            if (formatted !== value) {
              input.value = formatted;
              input.parentNode.dataset.value = formatted;
            }
          } catch (e) {
            input.classList.add('invalid-json');
          }
        }
      }, 10);
    });

    // Input handler - update mode class, clear invalid
    input.addEventListener('input', () => {
      input.classList.remove('invalid-json');
      const value = input.value.trim();
      if (value.startsWith('http://') || value.startsWith('https://')) {
        input.classList.add('url-mode');
        input.classList.remove('json-mode');
      } else {
        input.classList.remove('url-mode');
        input.classList.add('json-mode');
      }
    });

    // Display functions
    function displayResults(result) {
      // result has: valid, version, errors, warnings, source, warning (optional)
      let html = '';

      // Source info for URL fetches
      if (result.source && result.source !== 'direct input') {
        html += `<div class="source-info">Config found in: ${result.source}</div>`;
      }

      // Status warning for non-402
      if (result.warning) {
        html += `<div class="status-warning">${result.warning}</div>`;
      }

      // Existing validation result display (adapt to current format)
      // ... keep existing result rendering logic ...
      results.innerHTML = html + renderValidationResult(result);
    }

    function displayError(message) {
      results.innerHTML = `<div class="error">${message}</div>`;
    }
    ```

    Integrate with existing validation display code in index.html - the displayResults function should prepend source info to whatever format is already used.

    Reference Patterns 5 (loading state), 6 (CSS Grid auto-expand) from 02-RESEARCH.md.
    Handle Pitfall 3 (always re-enable button in finally block).
  </action>
  <verify>
    Script included: `grep 'src="input.js"' index.html`
    Script order correct: `grep -A1 'validator.js' index.html | grep 'input.js'`
    Loading class defined: `grep -E "\\.loading|loading.*opacity" index.html`
    Source display element: `grep "source-info" index.html`
    Input wrapper for auto-expand: `grep "input-wrapper" index.html`
    Click handler with try-finally: `grep -A10 "addEventListener.*click" index.html | grep "finally"`
    Calls handleValidation: `grep "handleValidation" index.html`
  </verify>
  <done>
    index.html updated with:
    - input.js script tag after validator.js
    - Smart input textarea wrapped in .input-wrapper for CSS Grid auto-expand
    - Placeholder "Paste a URL or x402 JSON config..."
    - Loading state CSS (.loading class with opacity/cursor)
    - Visual feedback CSS (.url-mode, .invalid-json border colors)
    - Click handler that disables button, calls handleValidation(), re-enables in finally
    - Paste handler that auto-formats JSON (skips if URL)
    - Input handler that updates mode classes
    - Source info display (.source-info) prepended to results
    - Status warning display (.status-warning) for non-402 responses
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify input and fetch functionality</name>
  <what-built>
    Smart input detection with URL fetching via CORS proxy:
    - Single textarea that auto-detects URL vs JSON
    - URL fetch with 5 second timeout
    - Config extraction from PAYMENT-REQUIRED header or response body
    - Loading states and error display
  </what-built>
  <how-to-verify>
    1. Open index.html in browser (python3 -m http.server 8000)
    2. Test JSON input:
       - Paste valid JSON config
       - Click Validate
       - Should show validation results immediately
       - Source info should NOT appear (direct input)
    3. Test URL input:
       - Enter URL of known x402 endpoint (or use a test URL)
       - Click Validate
       - Should show "Validating..." then results
       - Check source info shows "PAYMENT-REQUIRED header" or "response body"
    4. Test error handling:
       - Enter invalid URL (e.g., "not-a-url")
       - Should show "Invalid URL format" error
       - Enter unreachable URL
       - Should show timeout or network error after 5s
    5. Test loading state:
       - Button should be disabled during fetch
       - Button should re-enable after completion (success or error)
    6. Test auto-format:
       - Paste minified JSON
       - Should auto-format with indentation
  </how-to-verify>
  <resume-signal>Type "approved" if working, or describe specific issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] input.js exists with all required functions
- [ ] input.js calls validateX402Config from validator.js
- [ ] input.js constructs proxy URL with encodeURIComponent
- [ ] index.html includes input.js script after validator.js
- [ ] URL detection works (http:// and https://)
- [ ] JSON input validates immediately
- [ ] URL fetch shows loading state
- [ ] Config source displayed in results (header vs body)
- [ ] Errors display in results area
- [ ] Button disabled during fetch, re-enabled after
</verification>

<success_criteria>
User can paste either a URL or JSON config. URL inputs are fetched via proxy with proper timeout and error handling. Config source (header vs body) is displayed. Loading states prevent double-submit. validateX402Config from validator.js is called for all validation.
</success_criteria>

<output>
After completion, create `.planning/phases/02-input-proxy/02-02-SUMMARY.md`
</output>
